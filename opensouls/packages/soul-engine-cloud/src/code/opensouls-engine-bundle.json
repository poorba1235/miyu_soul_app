{"imports":["zod"],"exports":["ChatMessageRoleEnum","ContentTypeGuards","WorkingMemory","createCognitiveStep","forkStream","indentNicely","isAnthropicImage","isAudio","isGoogleAudio","isGoogleImage","isGoogleText","isImage","isOpenAIImage","isOpenAIText","isText","stripEntityAndVerb","stripEntityAndVerbFromStream","useActions","useBlueprintStore","useOrganizationStore","usePerceptions","useProcessManager","useProcessMemory","useRag","useSharedContext","useSoulMemory","useSoulStore","useTTS","useTool","z"],"reexports":[],"__syncModuleProgram__":"({   imports: $h‍_imports,   liveVar: $h‍_live,   onceVar: $h‍_once,   importMeta: $h‍____meta, }) => (function () { 'use strict';   let z2;$h‍_imports([[\"zod\", [[\"z\", [$h‍_a => (z2 = $h‍_a),$h‍_live[\"z2\"]]]]]]);$h‍_live.createCognitiveStep();Object.defineProperty(forkStream, 'name', {value: \"forkStream\"});$h‍_once.forkStream(forkStream);$h‍_live.indentNicely2();$h‍_live.stripEntityAndVerb();$h‍_live.stripEntityAndVerbFromStream();Object.defineProperty(isOpenAIText, 'name', {value: \"isOpenAIText\"});$h‍_once.isOpenAIText(isOpenAIText);Object.defineProperty(isGoogleText, 'name', {value: \"isGoogleText\"});$h‍_once.isGoogleText(isGoogleText);Object.defineProperty(isText, 'name', {value: \"isText\"});$h‍_once.isText(isText);Object.defineProperty(isOpenAIImage, 'name', {value: \"isOpenAIImage\"});$h‍_once.isOpenAIImage(isOpenAIImage);Object.defineProperty(isAnthropicImage, 'name', {value: \"isAnthropicImage\"});$h‍_once.isAnthropicImage(isAnthropicImage);Object.defineProperty(isGoogleImage, 'name', {value: \"isGoogleImage\"});$h‍_once.isGoogleImage(isGoogleImage);Object.defineProperty(isImage, 'name', {value: \"isImage\"});$h‍_once.isImage(isImage);Object.defineProperty(isGoogleAudio, 'name', {value: \"isGoogleAudio\"});$h‍_once.isGoogleAudio(isGoogleAudio);Object.defineProperty(isAudio, 'name', {value: \"isAudio\"});$h‍_once.isAudio(isAudio);$h‍_live.ContentTypeGuards();$h‍_live.useActions();$h‍_live.useTTS();$h‍_live.useProcessManager();$h‍_live.usePerceptions();$h‍_live.useProcessMemory();$h‍_live.useSoulStore();$h‍_live.useBlueprintStore();$h‍_live.useOrganizationStore();$h‍_live.useSoulMemory();$h‍_live.useRag();$h‍_live.useTool();$h‍_live.useSharedContext();$h‍_live.WorkingMemory();   \n\n\n\n// ../core/src/cognitiveStep.ts\nvar $c‍_createCognitiveStep=(transformationOptionsGenerator)=>{\n  return async( workingMemory, singleArg, opts=  {})=>  {\n    const transformOpts=  transformationOptionsGenerator(singleArg);\n    return workingMemory.transform(transformOpts, opts);\n   };\n };\n// ../../node_modules/web-streams-polyfill/dist/ponyfill.mjs\ncreateCognitiveStep=$c‍_createCognitiveStep;function e(){}\nfunction t(e2) {\n  return typeof e2==  \"object\"&&  e2!==  null||  typeof e2==  \"function\";\n }\nvar r=  e;\nfunction o(e2, t2) {\n  try {\n    Object.defineProperty(e2, \"name\", { value: t2, configurable: true});\n   }catch( e3) { }\n }\nvar n=  Promise;\nvar a=  Promise.resolve.bind(n);\nvar i=  Promise.prototype.then;\nvar l=  Promise.reject.bind(n);\nvar s=  a;\nfunction u(e2) {\n  return new n(e2);\n }\nfunction c(e2) {\n  return u((t2)=>  t2(e2));\n }\nfunction d(e2) {\n  return l(e2);\n }\nfunction f(e2, t2, r2) {\n  return i.call(e2, t2, r2);\n }\nfunction b(e2, t2, o2) {\n  f(f(e2, t2, o2), undefined, r);\n }\nfunction h(e2, t2) {\n  b(e2, t2);\n }\nfunction m(e2, t2) {\n  b(e2, undefined, t2);\n }\nfunction _(e2, t2, r2) {\n  return f(e2, t2, r2);\n }\nfunction p(e2) {\n  f(e2, undefined, r);\n }\nvar y=  (e2)=>  {\n  if( typeof queueMicrotask==  \"function\")\n    y=  queueMicrotask;else\n       {\n    const e3=  c(undefined);\n    y=  (t2)=>  f(e3, t2);\n   }\n  return y(e2);\n };\nfunction S(e2, t2, r2) {\n  if( typeof e2!=  \"function\")\n    throw new TypeError(\"Argument is not a function\");\n  return Function.prototype.apply.call(e2, t2, r2);\n }\nfunction g(e2, t2, r2) {\n  try {\n    return c(S(e2, t2, r2));\n   }catch( e3) {\n    return d(e3);\n   }\n }\n\nclass v {\n             constructor(){\n    this._cursor=  0, this._size=  0, this._front=  { _elements: [], _next: undefined},  this._back=  this._front, this._cursor=  0, this._size=  0;\n   }\n            get length(){\n    return this._size;\n   }\n      push(e2){\n    const t2=  this._back;\n    let r2=  t2;\n    t2._elements.length===  16383&&(  r2=  { _elements: [], _next: undefined}),  t2._elements.push(e2), r2!==  t2&&(  this._back=  r2, t2._next=  r2), ++this._size;\n   }\n       shift(){\n    const e2=  this._front;\n    let t2=  e2;\n    const r2=  this._cursor;\n    let o2=  r2+  1;\n    const n2=  e2._elements, a2=  n2[r2];\n    return o2===  16384&&(  t2=  e2._next, o2=  0), --this._size, this._cursor=  o2, e2!==  t2&&(  this._front=  t2), n2[r2]=  undefined, a2;\n   }\n         forEach(e2){\n    let t2=  this._cursor, r2=  this._front, o2=  r2._elements;\n    for(; !(t2===  o2.length&&  r2._next===  undefined||  t2===  o2.length&&(  r2=  r2._next, o2=  r2._elements, t2=  0, o2.length===  0));)\n      e2(o2[t2]), ++t2;\n   }\n      peek(){\n    const e2=  this._front, t2=  this._cursor;\n    return e2._elements[t2];\n   }}\n\nvar w=  Symbol(\"[[AbortSteps]]\");\nvar R=  Symbol(\"[[ErrorSteps]]\");\nvar T=  Symbol(\"[[CancelSteps]]\");\nvar C=  Symbol(\"[[PullSteps]]\");\nvar P=  Symbol(\"[[ReleaseSteps]]\");\nfunction q(e2, t2) {\n  e2._ownerReadableStream=  t2, t2._reader=  e2, t2._state===  \"readable\"?  B(e2):  t2._state===  \"closed\"?  function(e3) {\n    B(e3), A(e3);\n   }(e2): k(e2, t2._storedError);\n }\nfunction E(e2, t2) {\n  return Or(e2._ownerReadableStream, t2);\n }\nfunction W(e2) {\n  const t2=  e2._ownerReadableStream;\n  t2._state===  \"readable\"?  j(e2, new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")):  function(e3, t3) {\n    k(e3, t3);\n   }(e2,new TypeError(\"Reader was released and can no longer be used to monitor the stream's closedness\")), t2._readableStreamController[P](), t2._reader=  undefined, e2._ownerReadableStream=  undefined;\n }\nfunction O(e2) {\n  return new TypeError(\"Cannot \"+  e2+  \" a stream using a released reader\");\n }\nfunction B(e2) {\n  e2._closedPromise=  u((t2, r2)=>  {\n    e2._closedPromise_resolve=  t2, e2._closedPromise_reject=  r2;\n   });\n }\nfunction k(e2, t2) {\n  B(e2), j(e2, t2);\n }\nfunction j(e2, t2) {\n  e2._closedPromise_reject!==  undefined&&(  p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined);\n }\nfunction A(e2) {\n  e2._closedPromise_resolve!==  undefined&&(  e2._closedPromise_resolve(undefined), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined);\n }\nvar z=  Number.isFinite||  function(e2) {\n  return typeof e2==  \"number\"&&  isFinite(e2);\n };\nvar D=  Math.trunc||  function(e2) {\n  return e2<  0?  Math.ceil(e2):  Math.floor(e2);\n };\nfunction L(e2, t2) {\n  if( e2!==  undefined&&   typeof( r2=  e2)!=  \"object\"&&  typeof r2!=  \"function\")\n    throw new TypeError( `${t2} is not an object.`);\n  var r2;\n }\nfunction F(e2, t2) {\n  if( typeof e2!=  \"function\")\n    throw new TypeError( `${t2} is not a function.`);\n }\nfunction I(e2, t2) {\n  if( !function(e3) {\n    return typeof e3==  \"object\"&&  e3!==  null||  typeof e3==  \"function\";\n   }(e2))\n    throw new TypeError( `${t2} is not an object.`);\n }\nfunction $(e2, t2, r2) {\n  if( e2===  undefined)\n    throw new TypeError( `Parameter ${t2} is required in '${r2}'.`);\n }\nfunction M(e2, t2, r2) {\n  if( e2===  undefined)\n    throw new TypeError( `${t2} is required in '${r2}'.`);\n }\nfunction Y(e2) {\n  return Number(e2);\n }\nfunction x(e2) {\n  return e2===  0?  0:  e2;\n }\nfunction Q(e2, t2) {\n  const r2=  Number.MAX_SAFE_INTEGER;\n  let o2=  Number(e2);\n  if( o2=  x(o2), !z(o2))\n    throw new TypeError( `${t2} is not a finite number`);\n  if( o2=  function(e3) {\n    return x(D(e3));\n   }(o2),o2<  0||  o2>  r2)\n    throw new TypeError( `${t2} is outside the accepted range of 0 to ${r2}, inclusive`);\n  return z(o2)&&  o2!==  0?  o2:  0;\n }\nfunction N(e2, t2) {\n  if( !Er(e2))\n    throw new TypeError( `${t2} is not a ReadableStream.`);\n }\nfunction H(e2) {\n  return new ReadableStreamDefaultReader(e2);\n }\nfunction V(e2, t2) {\n  e2._reader._readRequests.push(t2);\n }\nfunction U(e2, t2, r2) {\n  const o2=  e2._reader._readRequests.shift();\n  r2?  o2._closeSteps():  o2._chunkSteps(t2);\n }\nfunction G(e2) {\n  return e2._reader._readRequests.length;\n }\nfunction X(e2) {\n  const t2=  e2._reader;\n  return t2!==  undefined&&  !!J(t2);\n }\n\nclass ReadableStreamDefaultReader {\n             constructor(e2){\n    if( $(e2, 1, \"ReadableStreamDefaultReader\"), N(e2, \"First parameter\"), Wr(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    q(this, e2), this._readRequests=  new v();\n   }\n            get closed(){\n    return J(this)?  this._closedPromise:  d(ee(\"closed\"));\n   }\n        cancel(e2=undefined){\n    return J(this)?  this._ownerReadableStream===  undefined?  d(O(\"cancel\")):  E(this, e2):  d(ee(\"cancel\"));\n   }\n      read(){\n    if( !J(this))\n      return d(ee(\"read\"));\n    if( this._ownerReadableStream===  undefined)\n      return d(O(\"read from\"));\n    let e2, t2;\n    const r2=  u((r3, o2)=>  {\n      e2=  r3, t2=  o2;\n     });\n    return K(this, { _chunkSteps: (t3)=>  e2({ value: t3, done: false}),  _closeSteps: ()=>  e2({ value: undefined, done: true}),  _errorSteps: (e3)=>  t2(e3)}),  r2;\n   }\n             releaseLock(){\n    if( !J(this))\n      throw ee(\"releaseLock\");\n    this._ownerReadableStream!==  undefined&&  function(e2) {\n      W(e2);\n      const t2=  new TypeError(\"Reader was released\");\n      Z(e2, t2);\n     }(this);\n   }}\n\nfunction J(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readRequests\")&&  e2 instanceof ReadableStreamDefaultReader;\n }\nfunction K(e2, t2) {\n  const r2=  e2._ownerReadableStream;\n  r2._disturbed=  true, r2._state===  \"closed\"?  t2._closeSteps():  r2._state===  \"errored\"?  t2._errorSteps(r2._storedError):  r2._readableStreamController[C](t2);\n }\nfunction Z(e2, t2) {\n  const r2=  e2._readRequests;\n  e2._readRequests=  new v(),r2.forEach((e3)=> {\n    e3._errorSteps(t2);\n   });\n }\nfunction ee(e2) {\n  return new TypeError( `ReadableStreamDefaultReader.prototype.${e2} can only be used on a ReadableStreamDefaultReader`);\n }\nvar te;\nvar re;\nvar oe;\nfunction ne(e2) {\n  return e2.slice();\n }\nfunction ae(e2, t2, r2, o2, n2) {\n  new Uint8Array(e2).set(new Uint8Array(r2, o2, n2), t2);\n }\nObject.defineProperties(ReadableStreamDefaultReader.prototype, { cancel: { enumerable: true},  read: { enumerable: true},  releaseLock: { enumerable: true},  closed: { enumerable: true}}),   o(ReadableStreamDefaultReader.prototype.cancel, \"cancel\"), o(ReadableStreamDefaultReader.prototype.read, \"read\"), o(ReadableStreamDefaultReader.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamDefaultReader.prototype, Symbol.toStringTag, { value: \"ReadableStreamDefaultReader\", configurable: true});\nvar ie=  (e2)=>(  ie=  typeof e2.transfer==  \"function\"?  (e3)=>  e3.transfer():  typeof structuredClone==  \"function\"?  (e3)=>  structuredClone(e3, { transfer: [e3]}):   (e3)=>  e3, ie(e2));\nvar le=  (e2)=>(  le=  typeof e2.detached==  \"boolean\"?  (e3)=>  e3.detached:  (e3)=>  e3.byteLength===  0, le(e2));\nfunction se(e2, t2, r2) {\n  if( e2.slice)\n    return e2.slice(t2, r2);\n  const o2=  r2-  t2, n2=  new ArrayBuffer(o2);\n  return ae(n2, 0, e2, t2, o2), n2;\n }\nfunction ue(e2, t2) {\n  const r2=  e2[t2];\n  if( r2!=  null) {\n    if( typeof r2!=  \"function\")\n      throw new TypeError( `${String(t2)} is not a function`);\n    return r2;\n   }\n }\nfunction ce(e2) {\n  try {\n    const { done: t2, value: r2}=   e2;\n    return f(s(r2), (e3)=>(  { done: t2, value: e3}));\n   }catch( e3) {\n    return d(e3);\n   }\n }\nvar de=  (oe=  (te=  Symbol.asyncIterator)!==  null&&  te!==  undefined?  te:  (re=  Symbol.for)===  null||  re===  undefined?  undefined:  re.call(Symbol, \"Symbol.asyncIterator\"))!==  null&&  oe!==  undefined?  oe:  \"@@asyncIterator\";\nfunction fe(e2, r2=  \"sync\", o2) {\n  if( o2===  undefined)\n    if( r2===  \"async\") {\n      if( (o2=  ue(e2, de))===  undefined) {\n        return function(e3) {\n          const r3=  { next() {\n            let t2;\n            try {\n              t2=  be(e3);\n             }catch( e4) {\n              return d(e4);\n             }\n            return ce(t2);\n           },return(r4) {\n            let o3;\n            try {\n              const t2=  ue(e3.iterator, \"return\");\n              if( t2===  undefined)\n                return c({ done: true, value: r4});\n              o3=  S(t2, e3.iterator, [r4]);\n             }catch( e4) {\n              return d(e4);\n             }\n            return t(o3)?  ce(o3):  d(new TypeError(\"The iterator.return() method must return an object\"));\n           }};\n          return { iterator: r3, nextMethod: r3.next, done: false};\n         }(fe(e2,\"sync\", ue(e2, Symbol.iterator)));\n       }\n     }else\n      o2=  ue(e2, Symbol.iterator);\n  if( o2===  undefined)\n    throw new TypeError(\"The object is not iterable\");\n  const n2=  S(o2, e2, []);\n  if( !t(n2))\n    throw new TypeError(\"The iterator method must return an object\");\n  return { iterator: n2, nextMethod: n2.next, done: false};\n }\nfunction be(e2) {\n  const r2=  S(e2.nextMethod, e2.iterator, []);\n  if( !t(r2))\n    throw new TypeError(\"The iterator.next() method must return an object\");\n  return r2;\n }\n\nclass he {\n             constructor(e2,t2){\n    this._ongoingPromise=  undefined, this._isFinished=  false, this._reader=  e2, this._preventCancel=  t2;\n   }\n      next(){\n    const e2=  ()=>  this._nextSteps();\n    return this._ongoingPromise=  this._ongoingPromise?  _(this._ongoingPromise, e2, e2):  e2(), this._ongoingPromise;\n   }\n        return(e2){\n    const t2=  ()=>  this._returnSteps(e2);\n    return this._ongoingPromise=  this._ongoingPromise?  _(this._ongoingPromise, t2, t2):  t2(), this._ongoingPromise;\n   }\n            _nextSteps(){\n    if( this._isFinished)\n      return Promise.resolve({ value: undefined, done: true});\n    const e2=  this._reader;\n    let t2, r2;\n    const o2=  u((e3, o3)=>  {\n      t2=  e3, r2=  o3;\n     });\n    return K(e2, { _chunkSteps: (e3)=>  {\n      this._ongoingPromise=  undefined, y(()=>  t2({ value: e3, done: false}));\n     },_closeSteps: ()=>  {\n      this._ongoingPromise=  undefined, this._isFinished=  true, W(e2), t2({ value: undefined, done: true});\n     },_errorSteps: (t3)=>  {\n      this._ongoingPromise=  undefined, this._isFinished=  true, W(e2), r2(t3);\n     }}), o2;\n   }\n              _returnSteps(e2){\n    if( this._isFinished)\n      return Promise.resolve({ value: e2, done: true});\n    this._isFinished=  true;\n    const t2=  this._reader;\n    if( !this._preventCancel) {\n      const r2=  E(t2, e2);\n      return W(t2), _(r2, ()=>(  { value: e2, done: true}));\n     }\n    return W(t2), c({ value: e2, done: true});\n   }}\n\nvar me=  { next() {\n  return _e(this)?  this._asyncIteratorImpl.next():  d(pe(\"next\"));\n },return(e2) {\n  return _e(this)?  this._asyncIteratorImpl.return(e2):  d(pe(\"return\"));\n },[de]() {\n  return this;\n }};\nfunction _e(e2) {\n  if( !t(e2))\n    return false;\n  if( !Object.prototype.hasOwnProperty.call(e2, \"_asyncIteratorImpl\"))\n    return false;\n  try {\n    return e2._asyncIteratorImpl instanceof he;\n   }catch( e3) {\n    return false;\n   }\n }\nfunction pe(e2) {\n  return new TypeError( `ReadableStreamAsyncIterator.${e2} can only be used on a ReadableSteamAsyncIterator`);\n }\nObject.defineProperty(me, de, { enumerable: false});\nvar ye=  Number.isNaN||  function(e2) {\n  return e2!=  e2;\n };\nfunction Se(e2) {\n  const t2=  se(e2.buffer, e2.byteOffset, e2.byteOffset+  e2.byteLength);\n  return new Uint8Array(t2);\n }\nfunction ge(e2) {\n  const t2=  e2._queue.shift();\n  return e2._queueTotalSize-=  t2.size, e2._queueTotalSize<  0&&(  e2._queueTotalSize=  0), t2.value;\n }\nfunction ve(e2, t2, r2) {\n  if( typeof( o2=  r2)!=  \"number\"||  ye(o2)||  o2<  0||  r2===  1/  0)\n    throw new RangeError(\"Size must be a finite, non-NaN, non-negative number.\");\n  var o2;\n  e2._queue.push({ value: t2, size: r2}),  e2._queueTotalSize+=  r2;\n }\nfunction we(e2) {\n  e2._queue=  new v(),e2._queueTotalSize= 0;\n }\nfunction Re(e2) {\n  return e2===  DataView;\n }\n\nclass ReadableStreamBYOBRequest {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n          get view(){\n    if( !Ce(this))\n      throw Ke(\"view\");\n    return this._view;\n   }\n         respond(e2){\n    if( !Ce(this))\n      throw Ke(\"respond\");\n    if( $(e2, 1, \"respond\"), e2=  Q(e2, \"First parameter\"), this._associatedReadableByteStreamController===  undefined)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    if( le(this._view.buffer))\n      throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be used as a response\");\n    Ge(this._associatedReadableByteStreamController, e2);\n   }\n                    respondWithNewView(e2){\n    if( !Ce(this))\n      throw Ke(\"respondWithNewView\");\n    if( $(e2, 1, \"respondWithNewView\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"You can only respond with array buffer views\");\n    if( this._associatedReadableByteStreamController===  undefined)\n      throw new TypeError(\"This BYOB request has been invalidated\");\n    if( le(e2.buffer))\n      throw new TypeError(\"The given view's buffer has been detached and so cannot be used as a response\");\n    Xe(this._associatedReadableByteStreamController, e2);\n   }}\n\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, { respond: { enumerable: true},  respondWithNewView: { enumerable: true},  view: { enumerable: true}}),   o(ReadableStreamBYOBRequest.prototype.respond, \"respond\"), o(ReadableStreamBYOBRequest.prototype.respondWithNewView, \"respondWithNewView\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamBYOBRequest.prototype, Symbol.toStringTag, { value: \"ReadableStreamBYOBRequest\", configurable: true});\n\nclass ReadableByteStreamController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get byobRequest(){\n    if( !Te(this))\n      throw Ze(\"byobRequest\");\n    return Ve(this);\n   }\n                 get desiredSize(){\n    if( !Te(this))\n      throw Ze(\"desiredSize\");\n    return Ue(this);\n   }\n       close(){\n    if( !Te(this))\n      throw Ze(\"close\");\n    if( this._closeRequested)\n      throw new TypeError(\"The stream has already been closed; do not close it again!\");\n    const e2=  this._controlledReadableByteStream._state;\n    if( e2!==  \"readable\")\n      throw new TypeError( `The stream (in ${e2} state) is not in the readable state and cannot be closed`);\n    xe(this);\n   }\n         enqueue(e2){\n    if( !Te(this))\n      throw Ze(\"enqueue\");\n    if( $(e2, 1, \"enqueue\"), !ArrayBuffer.isView(e2))\n      throw new TypeError(\"chunk must be an array buffer view\");\n    if( e2.byteLength===  0)\n      throw new TypeError(\"chunk must have non-zero byteLength\");\n    if( e2.buffer.byteLength===  0)\n      throw new TypeError(\"chunk's buffer must have non-zero byteLength\");\n    if( this._closeRequested)\n      throw new TypeError(\"stream is closed or draining\");\n    const t2=  this._controlledReadableByteStream._state;\n    if( t2!==  \"readable\")\n      throw new TypeError( `The stream (in ${t2} state) is not in the readable state and cannot be enqueued to`);\n    Qe(this, e2);\n   }\n       error(e2=undefined){\n    if( !Te(this))\n      throw Ze(\"error\");\n    Ne(this, e2);\n   }\n    [T](e2){\n    qe(this), we(this);\n    const t2=  this._cancelAlgorithm(e2);\n    return Ye(this), t2;\n   }\n    [C](e2){\n    const t2=  this._controlledReadableByteStream;\n    if( this._queueTotalSize>  0)\n      return void He(this, e2);\n    const r2=  this._autoAllocateChunkSize;\n    if( r2!==  undefined) {\n      let t3;\n      try {\n        t3=  new ArrayBuffer(r2);\n       }catch( t4) {\n        return void e2._errorSteps(t4);\n       }\n      const o2=  { buffer: t3, bufferByteLength: r2, byteOffset: 0, byteLength: r2, bytesFilled: 0, minimumFill: 1, elementSize: 1, viewConstructor: Uint8Array, readerType: \"default\"};\n      this._pendingPullIntos.push(o2);\n     }\n    V(t2, e2), Pe(this);\n   }\n    [P](){\n    if( this._pendingPullIntos.length>  0) {\n      const e2=  this._pendingPullIntos.peek();\n      e2.readerType=  \"none\", this._pendingPullIntos=  new v(),this._pendingPullIntos.push(e2);\n     }\n   }}\n\nfunction Te(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableByteStream\")&&  e2 instanceof ReadableByteStreamController;\n }\nfunction Ce(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_associatedReadableByteStreamController\")&&  e2 instanceof ReadableStreamBYOBRequest;\n }\nfunction Pe(e2) {\n  const t2=  function(e3) {\n    const t3=  e3._controlledReadableByteStream;\n    if( t3._state!==  \"readable\")\n      return false;\n    if( e3._closeRequested)\n      return false;\n    if( !e3._started)\n      return false;\n    if( X(t3)&&  G(t3)>  0)\n      return true;\n    if( nt(t3)&&  ot(t3)>  0)\n      return true;\n    const r2=  Ue(e3);\n    if( r2>  0)\n      return true;\n    return false;\n   }(e2);\n  if( !t2)\n    return;\n  if( e2._pulling)\n    return void( e2._pullAgain=  true);\n  e2._pulling=  true;\n  b(e2._pullAlgorithm(), ()=>(  e2._pulling=  false, e2._pullAgain&&(  e2._pullAgain=  false, Pe(e2)), null), (t3)=>(  Ne(e2, t3), null));\n }\nfunction qe(e2) {\n  Le(e2), e2._pendingPullIntos=  new v();\n }\nfunction Ee(e2, t2) {\n  let r2=  false;\n  e2._state===  \"closed\"&&(  r2=  true);\n  const o2=  Oe(t2);\n  t2.readerType===  \"default\"?  U(e2, o2, r2):  function(e3, t3, r3) {\n    const o3=  e3._reader, n2=  o3._readIntoRequests.shift();\n    r3?  n2._closeSteps(t3):  n2._chunkSteps(t3);\n   }(e2,o2, r2);\n }\nfunction We(e2, t2) {\n  for( let r2=  0;r2<  t2.length; ++r2)\n    Ee(e2, t2[r2]);\n }\nfunction Oe(e2) {\n  const { bytesFilled: t2, elementSize: r2}=   e2;\n  return new e2.viewConstructor(e2.buffer, e2.byteOffset, t2/  r2);\n }\nfunction Be(e2, t2, r2, o2) {\n  e2._queue.push({ buffer: t2, byteOffset: r2, byteLength: o2}),  e2._queueTotalSize+=  o2;\n }\nfunction ke(e2, t2, r2, o2) {\n  let n2;\n  try {\n    n2=  se(t2, r2, r2+  o2);\n   }catch( t3) {\n    throw Ne(e2, t3), t3;\n   }\n  Be(e2, n2, 0, o2);\n }\nfunction je(e2, t2) {\n  t2.bytesFilled>  0&&  ke(e2, t2.buffer, t2.byteOffset, t2.bytesFilled), Me(e2);\n }\nfunction Ae(e2, t2) {\n  const r2=  Math.min(e2._queueTotalSize, t2.byteLength-  t2.bytesFilled), o2=  t2.bytesFilled+  r2;\n  let n2=  r2, a2=  false;\n  const i2=  o2-  o2%  t2.elementSize;\n  i2>=  t2.minimumFill&&(  n2=  i2-  t2.bytesFilled, a2=  true);\n  const l2=  e2._queue;\n  for(; n2>  0;)  {\n    const r3=  l2.peek(), o3=  Math.min(n2, r3.byteLength), a3=  t2.byteOffset+  t2.bytesFilled;\n    ae(t2.buffer, a3, r3.buffer, r3.byteOffset, o3), r3.byteLength===  o3?  l2.shift():(  r3.byteOffset+=  o3, r3.byteLength-=  o3), e2._queueTotalSize-=  o3, ze(e2, o3, t2), n2-=  o3;\n   }\n  return a2;\n }\nfunction ze(e2, t2, r2) {\n  r2.bytesFilled+=  t2;\n }\nfunction De(e2) {\n  e2._queueTotalSize===  0&&  e2._closeRequested?(  Ye(e2), Br(e2._controlledReadableByteStream)):  Pe(e2);\n }\nfunction Le(e2) {\n  e2._byobRequest!==  null&&(  e2._byobRequest._associatedReadableByteStreamController=  undefined, e2._byobRequest._view=  null, e2._byobRequest=  null);\n }\nfunction Fe(e2) {\n  const t2=  [];\n  for(; e2._pendingPullIntos.length>  0&&  e2._queueTotalSize!==  0;)  {\n    const r2=  e2._pendingPullIntos.peek();\n    Ae(e2, r2)&&(  Me(e2), t2.push(r2));\n   }\n  return t2;\n }\nfunction Ie(e2, t2, r2, o2) {\n  const n2=  e2._controlledReadableByteStream, a2=  t2.constructor, i2=  function(e3) {\n    return Re(e3)?  1:  e3.BYTES_PER_ELEMENT;\n   }(a2),{ byteOffset: l2, byteLength: s2}=   t2, u2=  r2*  i2;\n  let c2;\n  try {\n    c2=  ie(t2.buffer);\n   }catch( e3) {\n    return void o2._errorSteps(e3);\n   }\n  const d2=  { buffer: c2, bufferByteLength: c2.byteLength, byteOffset: l2, byteLength: s2, bytesFilled: 0, minimumFill: u2, elementSize: i2, viewConstructor: a2, readerType: \"byob\"};\n  if( e2._pendingPullIntos.length>  0)\n    return e2._pendingPullIntos.push(d2), void rt(n2, o2);\n  if( n2._state===  \"closed\") {\n    const e3=  new a2(d2.buffer, d2.byteOffset, 0);\n    return void o2._closeSteps(e3);\n   }\n  if( e2._queueTotalSize>  0) {\n    if( Ae(e2, d2)) {\n      const t3=  Oe(d2);\n      return De(e2), void o2._chunkSteps(t3);\n     }\n    if( e2._closeRequested) {\n      const t3=  new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n      return Ne(e2, t3), void o2._errorSteps(t3);\n     }\n   }\n  e2._pendingPullIntos.push(d2), rt(n2, o2), Pe(e2);\n }\nfunction $e(e2, t2) {\n  const r2=  e2._pendingPullIntos.peek();\n  Le(e2);\n  e2._controlledReadableByteStream._state===  \"closed\"?  function(e3, t3) {\n    t3.readerType===  \"none\"&&  Me(e3);\n    const r3=  e3._controlledReadableByteStream;\n    if( nt(r3)) {\n      const t4=  [];\n      for(; t4.length<  ot(r3);)\n        t4.push(Me(e3));\n      We(r3, t4);\n     }\n   }(e2,r2):  function(e3, t3, r3) {\n    if( ze(0, t3, r3), r3.readerType===  \"none\") {\n      je(e3, r3);\n      const t4=  Fe(e3);\n      return void We(e3._controlledReadableByteStream, t4);\n     }\n    if( r3.bytesFilled<  r3.minimumFill)\n      return;\n    Me(e3);\n    const o2=  r3.bytesFilled%  r3.elementSize;\n    if( o2>  0) {\n      const t4=  r3.byteOffset+  r3.bytesFilled;\n      ke(e3, r3.buffer, t4-  o2, o2);\n     }\n    r3.bytesFilled-=  o2;\n    const n2=  Fe(e3);\n    Ee(e3._controlledReadableByteStream, r3), We(e3._controlledReadableByteStream, n2);\n   }(e2,t2, r2), Pe(e2);\n }\nfunction Me(e2) {\n  return e2._pendingPullIntos.shift();\n }\nfunction Ye(e2) {\n  e2._pullAlgorithm=  undefined, e2._cancelAlgorithm=  undefined;\n }\nfunction xe(e2) {\n  const t2=  e2._controlledReadableByteStream;\n  if( !e2._closeRequested&&  t2._state===  \"readable\")\n    if( e2._queueTotalSize>  0)\n      e2._closeRequested=  true;else\n         {\n      if( e2._pendingPullIntos.length>  0) {\n        const t3=  e2._pendingPullIntos.peek();\n        if( t3.bytesFilled%  t3.elementSize!==  0) {\n          const t4=  new TypeError(\"Insufficient bytes to fill elements in the given buffer\");\n          throw Ne(e2, t4), t4;\n         }\n       }\n      Ye(e2), Br(t2);\n     }\n }\nfunction Qe(e2, t2) {\n  const r2=  e2._controlledReadableByteStream;\n  if( e2._closeRequested||  r2._state!==  \"readable\")\n    return;\n  const { buffer: o2, byteOffset: n2, byteLength: a2}=   t2;\n  if( le(o2))\n    throw new TypeError(\"chunk's buffer is detached and so cannot be enqueued\");\n  const i2=  ie(o2);\n  if( e2._pendingPullIntos.length>  0) {\n    const t3=  e2._pendingPullIntos.peek();\n    if( le(t3.buffer))\n      throw new TypeError(\"The BYOB request's buffer has been detached and so cannot be filled with an enqueued chunk\");\n    Le(e2), t3.buffer=  ie(t3.buffer), t3.readerType===  \"none\"&&  je(e2, t3);\n   }\n  if( X(r2)){\n    if( function(e3) {\n      const t3=  e3._controlledReadableByteStream._reader;\n      for(; t3._readRequests.length>  0;)  {\n        if( e3._queueTotalSize===  0)\n          return;\n        He(e3, t3._readRequests.shift());\n       }\n     }(e2),G(r2)===  0)\n      Be(e2, i2, n2, a2);else\n         {\n      e2._pendingPullIntos.length>  0&&  Me(e2);\n      U(r2, new Uint8Array(i2, n2, a2), false);\n     }}else\n       if( nt(r2)) {\n    Be(e2, i2, n2, a2);\n    We(r2, Fe(e2));\n   }else\n    Be(e2, i2, n2, a2);\n  Pe(e2);\n }\nfunction Ne(e2, t2) {\n  const r2=  e2._controlledReadableByteStream;\n  r2._state===  \"readable\"&&(  qe(e2), we(e2), Ye(e2), kr(r2, t2));\n }\nfunction He(e2, t2) {\n  const r2=  e2._queue.shift();\n  e2._queueTotalSize-=  r2.byteLength, De(e2);\n  const o2=  new Uint8Array(r2.buffer, r2.byteOffset, r2.byteLength);\n  t2._chunkSteps(o2);\n }\nfunction Ve(e2) {\n  if( e2._byobRequest===  null&&  e2._pendingPullIntos.length>  0) {\n    const t2=  e2._pendingPullIntos.peek(), r2=  new Uint8Array(t2.buffer, t2.byteOffset+  t2.bytesFilled, t2.byteLength-  t2.bytesFilled), o2=  Object.create(ReadableStreamBYOBRequest.prototype);\n    (function(e3, t3, r3) {\n      e3._associatedReadableByteStreamController=  t3, e3._view=  r3;\n     })(o2,e2, r2), e2._byobRequest=  o2;\n   }\n  return e2._byobRequest;\n }\nfunction Ue(e2) {\n  const t2=  e2._controlledReadableByteStream._state;\n  return t2===  \"errored\"?  null:  t2===  \"closed\"?  0:  e2._strategyHWM-  e2._queueTotalSize;\n }\nfunction Ge(e2, t2) {\n  const r2=  e2._pendingPullIntos.peek();\n  if( e2._controlledReadableByteStream._state===  \"closed\") {\n    if( t2!==  0)\n      throw new TypeError(\"bytesWritten must be 0 when calling respond() on a closed stream\");\n   }else {\n    if( t2===  0)\n      throw new TypeError(\"bytesWritten must be greater than 0 when calling respond() on a readable stream\");\n    if( r2.bytesFilled+  t2>  r2.byteLength)\n      throw new RangeError(\"bytesWritten out of range\");\n   }\n  r2.buffer=  ie(r2.buffer), $e(e2, t2);\n }\nfunction Xe(e2, t2) {\n  const r2=  e2._pendingPullIntos.peek();\n  if( e2._controlledReadableByteStream._state===  \"closed\") {\n    if( t2.byteLength!==  0)\n      throw new TypeError(\"The view's length must be 0 when calling respondWithNewView() on a closed stream\");\n   }else if( t2.byteLength===  0)\n    throw new TypeError(\"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream\");\n  if( r2.byteOffset+  r2.bytesFilled!==  t2.byteOffset)\n    throw new RangeError(\"The region specified by view does not match byobRequest\");\n  if( r2.bufferByteLength!==  t2.buffer.byteLength)\n    throw new RangeError(\"The buffer of view has different capacity than byobRequest\");\n  if( r2.bytesFilled+  t2.byteLength>  r2.byteLength)\n    throw new RangeError(\"The region specified by view is larger than byobRequest\");\n  const o2=  t2.byteLength;\n  r2.buffer=  ie(t2.buffer), $e(e2, o2);\n }\nfunction Je(e2, t2, r2, o2, n2, a2, i2) {\n  t2._controlledReadableByteStream=  e2, t2._pullAgain=  false, t2._pulling=  false, t2._byobRequest=  null, t2._queue=  t2._queueTotalSize=  undefined, we(t2), t2._closeRequested=  false, t2._started=  false, t2._strategyHWM=  a2, t2._pullAlgorithm=  o2, t2._cancelAlgorithm=  n2, t2._autoAllocateChunkSize=  i2, t2._pendingPullIntos=  new v(),e2._readableStreamController= t2;\n  b(c(r2()), ()=>(  t2._started=  true, Pe(t2), null), (e3)=>(  Ne(t2, e3), null));\n }\nfunction Ke(e2) {\n  return new TypeError( `ReadableStreamBYOBRequest.prototype.${e2} can only be used on a ReadableStreamBYOBRequest`);\n }\nfunction Ze(e2) {\n  return new TypeError( `ReadableByteStreamController.prototype.${e2} can only be used on a ReadableByteStreamController`);\n }\nfunction et(e2, t2) {\n  if( (e2=   `${e2}`)!== \"byob\")\n    throw new TypeError( `${t2} '${e2}' is not a valid enumeration value for ReadableStreamReaderMode`);\n  return e2;\n }\nfunction tt(e2) {\n  return new ReadableStreamBYOBReader(e2);\n }\nfunction rt(e2, t2) {\n  e2._reader._readIntoRequests.push(t2);\n }\nfunction ot(e2) {\n  return e2._reader._readIntoRequests.length;\n }\nfunction nt(e2) {\n  const t2=  e2._reader;\n  return t2!==  undefined&&  !!at(t2);\n }\nObject.defineProperties(ReadableByteStreamController.prototype, { close: { enumerable: true},  enqueue: { enumerable: true},  error: { enumerable: true},  byobRequest: { enumerable: true},  desiredSize: { enumerable: true}}),   o(ReadableByteStreamController.prototype.close, \"close\"), o(ReadableByteStreamController.prototype.enqueue, \"enqueue\"), o(ReadableByteStreamController.prototype.error, \"error\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableByteStreamController.prototype, Symbol.toStringTag, { value: \"ReadableByteStreamController\", configurable: true});\n\nclass ReadableStreamBYOBReader {\n             constructor(e2){\n    if( $(e2, 1, \"ReadableStreamBYOBReader\"), N(e2, \"First parameter\"), Wr(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive reading by another reader\");\n    if( !Te(e2._readableStreamController))\n      throw new TypeError(\"Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source\");\n    q(this, e2), this._readIntoRequests=  new v();\n   }\n            get closed(){\n    return at(this)?  this._closedPromise:  d(st(\"closed\"));\n   }\n        cancel(e2=undefined){\n    return at(this)?  this._ownerReadableStream===  undefined?  d(O(\"cancel\")):  E(this, e2):  d(st(\"cancel\"));\n   }\n      read(e2,t2={}){\n    if( !at(this))\n      return d(st(\"read\"));\n    if( !ArrayBuffer.isView(e2))\n      return d(new TypeError(\"view must be an array buffer view\"));\n    if( e2.byteLength===  0)\n      return d(new TypeError(\"view must have non-zero byteLength\"));\n    if( e2.buffer.byteLength===  0)\n      return d(new TypeError(\"view's buffer must have non-zero byteLength\"));\n    if( le(e2.buffer))\n      return d(new TypeError(\"view's buffer has been detached\"));\n    let r2;\n    try {\n      r2=  function(e3, t3) {\n        var r3;\n        return L(e3, t3), { min: Q((r3=  e3==  null?  undefined:  e3.min)!==  null&&  r3!==  undefined?  r3:  1,  `${t3} has member 'min' that`)};\n       }(t2,\"options\");\n     }catch( e3) {\n      return d(e3);\n     }\n    const o2=  r2.min;\n    if( o2===  0)\n      return d(new TypeError(\"options.min must be greater than 0\"));\n    if( function(e3) {\n      return Re(e3.constructor);\n     }(e2)){\n      if( o2>  e2.byteLength)\n        return d(new RangeError(\"options.min must be less than or equal to view's byteLength\"));\n     }else if( o2>  e2.length)\n      return d(new RangeError(\"options.min must be less than or equal to view's length\"));\n    if( this._ownerReadableStream===  undefined)\n      return d(O(\"read from\"));\n    let n2, a2;\n    const i2=  u((e3, t3)=>  {\n      n2=  e3, a2=  t3;\n     });\n    return it(this, e2, o2, { _chunkSteps: (e3)=>  n2({ value: e3, done: false}),  _closeSteps: (e3)=>  n2({ value: e3, done: true}),  _errorSteps: (e3)=>  a2(e3)}),  i2;\n   }\n             releaseLock(){\n    if( !at(this))\n      throw st(\"releaseLock\");\n    this._ownerReadableStream!==  undefined&&  function(e2) {\n      W(e2);\n      const t2=  new TypeError(\"Reader was released\");\n      lt(e2, t2);\n     }(this);\n   }}\n\nfunction at(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readIntoRequests\")&&  e2 instanceof ReadableStreamBYOBReader;\n }\nfunction it(e2, t2, r2, o2) {\n  const n2=  e2._ownerReadableStream;\n  n2._disturbed=  true, n2._state===  \"errored\"?  o2._errorSteps(n2._storedError):  Ie(n2._readableStreamController, t2, r2, o2);\n }\nfunction lt(e2, t2) {\n  const r2=  e2._readIntoRequests;\n  e2._readIntoRequests=  new v(),r2.forEach((e3)=> {\n    e3._errorSteps(t2);\n   });\n }\nfunction st(e2) {\n  return new TypeError( `ReadableStreamBYOBReader.prototype.${e2} can only be used on a ReadableStreamBYOBReader`);\n }\nfunction ut(e2, t2) {\n  const { highWaterMark: r2}=   e2;\n  if( r2===  undefined)\n    return t2;\n  if( ye(r2)||  r2<  0)\n    throw new RangeError(\"Invalid highWaterMark\");\n  return r2;\n }\nfunction ct(e2) {\n  const { size: t2}=   e2;\n  return t2||(  ()=>  1);\n }\nfunction dt(e2, t2) {\n  L(e2, t2);\n  const r2=  e2==  null?  undefined:  e2.highWaterMark, o2=  e2==  null?  undefined:  e2.size;\n  return { highWaterMark: r2===  undefined?  undefined:  Y(r2), size: o2===  undefined?  undefined:  ft(o2,  `${t2} has member 'size' that`)};\n }\nfunction ft(e2, t2) {\n  return F(e2, t2), (t3)=>  Y(e2(t3));\n }\nfunction bt(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  g(e2, t2, [r3]);\n }\nfunction ht(e2, t2, r2) {\n  return F(e2, r2), ()=>  g(e2, t2, []);\n }\nfunction mt(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  S(e2, t2, [r3]);\n }\nfunction _t(e2, t2, r2) {\n  return F(e2, r2), (r3, o2)=>  g(e2, t2, [r3, o2]);\n }\nfunction pt(e2, t2) {\n  if( !gt(e2))\n    throw new TypeError( `${t2} is not a WritableStream.`);\n }\nObject.defineProperties(ReadableStreamBYOBReader.prototype, { cancel: { enumerable: true},  read: { enumerable: true},  releaseLock: { enumerable: true},  closed: { enumerable: true}}),   o(ReadableStreamBYOBReader.prototype.cancel, \"cancel\"), o(ReadableStreamBYOBReader.prototype.read, \"read\"), o(ReadableStreamBYOBReader.prototype.releaseLock, \"releaseLock\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamBYOBReader.prototype, Symbol.toStringTag, { value: \"ReadableStreamBYOBReader\", configurable: true});\n\nclass WritableStream {\n             constructor(e2={},t2={}){\n    e2===  undefined?  e2=  null:  I(e2, \"First parameter\");\n    const r2=  dt(t2, \"Second parameter\"), o2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.abort, o3=  e3==  null?  undefined:  e3.close, n3=  e3==  null?  undefined:  e3.start, a2=  e3==  null?  undefined:  e3.type, i2=  e3==  null?  undefined:  e3.write;\n      return { abort: r3===  undefined?  undefined:  bt(r3, e3,  `${t3} has member 'abort' that`),close: o3===  undefined?  undefined:  ht(o3, e3,  `${t3} has member 'close' that`),start: n3===  undefined?  undefined:  mt(n3, e3,  `${t3} has member 'start' that`),write: i2===  undefined?  undefined:  _t(i2, e3,  `${t3} has member 'write' that`),type: a2};\n     }(e2,\"First parameter\");\n    St(this);\n    if( o2.type!==  undefined)\n      throw new RangeError(\"Invalid type is specified\");\n    const n2=  ct(r2);\n    (function(e3, t3, r3, o3) {\n      const n3=  Object.create(WritableStreamDefaultController.prototype);\n      let a2, i2, l2, s2;\n      a2=  t3.start!==  undefined?  ()=>  t3.start(n3):  ()=>  { };\n      i2=  t3.write!==  undefined?  (e4)=>  t3.write(e4, n3):  ()=>  c(undefined);\n      l2=  t3.close!==  undefined?  ()=>  t3.close():  ()=>  c(undefined);\n      s2=  t3.abort!==  undefined?  (e4)=>  t3.abort(e4):  ()=>  c(undefined);\n      Ft(e3, n3, a2, i2, l2, s2, r3, o3);\n     })(this,o2, ut(r2, 1), n2);\n   }\n            get locked(){\n    if( !gt(this))\n      throw Nt(\"locked\");\n    return vt(this);\n   }\n       abort(e2=undefined){\n    return gt(this)?  vt(this)?  d(new TypeError(\"Cannot abort a stream that already has a writer\")):  wt(this, e2):  d(Nt(\"abort\"));\n   }\n       close(){\n    return gt(this)?  vt(this)?  d(new TypeError(\"Cannot close a stream that already has a writer\")):  qt(this)?  d(new TypeError(\"Cannot close an already-closing stream\")):  Rt(this):  d(Nt(\"close\"));\n   }\n           getWriter(){\n    if( !gt(this))\n      throw Nt(\"getWriter\");\n    return yt(this);\n   }}\n\nfunction yt(e2) {\n  return new WritableStreamDefaultWriter(e2);\n }\nfunction St(e2) {\n  e2._state=  \"writable\", e2._storedError=  undefined, e2._writer=  undefined, e2._writableStreamController=  undefined, e2._writeRequests=  new v(),e2._inFlightWriteRequest= undefined, e2._closeRequest=  undefined, e2._inFlightCloseRequest=  undefined, e2._pendingAbortRequest=  undefined, e2._backpressure=  false;\n }\nfunction gt(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_writableStreamController\")&&  e2 instanceof WritableStream;\n }\nfunction vt(e2) {\n  return e2._writer!==  undefined;\n }\nfunction wt(e2, t2) {\n  var r2;\n  if( e2._state===  \"closed\"||  e2._state===  \"errored\")\n    return c(undefined);\n  e2._writableStreamController._abortReason=  t2, (r2=  e2._writableStreamController._abortController)===  null||  r2===  undefined||  r2.abort(t2);\n  const o2=  e2._state;\n  if( o2===  \"closed\"||  o2===  \"errored\")\n    return c(undefined);\n  if( e2._pendingAbortRequest!==  undefined)\n    return e2._pendingAbortRequest._promise;\n  let n2=  false;\n  o2===  \"erroring\"&&(  n2=  true, t2=  undefined);\n  const a2=  u((r3, o3)=>  {\n    e2._pendingAbortRequest=  { _promise: undefined, _resolve: r3, _reject: o3, _reason: t2, _wasAlreadyErroring: n2};\n   });\n  return e2._pendingAbortRequest._promise=  a2, n2||  Ct(e2, t2), a2;\n }\nfunction Rt(e2) {\n  const t2=  e2._state;\n  if( t2===  \"closed\"||  t2===  \"errored\")\n    return d(new TypeError( `The stream (in ${t2} state) is not in the writable state and cannot be closed`));\n  const r2=  u((t3, r3)=>  {\n    const o3=  { _resolve: t3, _reject: r3};\n    e2._closeRequest=  o3;\n   }),o2=  e2._writer;\n  var n2;\n  return o2!==  undefined&&  e2._backpressure&&  t2===  \"writable\"&&  or(o2), ve(n2=  e2._writableStreamController, Dt, 0), Mt(n2), r2;\n }\nfunction Tt(e2, t2) {\n  e2._state!==  \"writable\"?  Pt(e2):  Ct(e2, t2);\n }\nfunction Ct(e2, t2) {\n  const r2=  e2._writableStreamController;\n  e2._state=  \"erroring\", e2._storedError=  t2;\n  const o2=  e2._writer;\n  o2!==  undefined&&  jt(o2, t2), !function(e3) {\n    if( e3._inFlightWriteRequest===  undefined&&  e3._inFlightCloseRequest===  undefined)\n      return false;\n    return true;\n   }(e2)&& r2._started&&  Pt(e2);\n }\nfunction Pt(e2) {\n  e2._state=  \"errored\", e2._writableStreamController[R]();\n  const t2=  e2._storedError;\n  if( e2._writeRequests.forEach((e3)=>  {\n    e3._reject(t2);\n   }),e2._writeRequests=  new v(),e2._pendingAbortRequest=== undefined)\n    return void Et(e2);\n  const r2=  e2._pendingAbortRequest;\n  if( e2._pendingAbortRequest=  undefined, r2._wasAlreadyErroring)\n    return r2._reject(t2), void Et(e2);\n  b(e2._writableStreamController[w](r2._reason), ()=>(  r2._resolve(), Et(e2), null), (t3)=>(  r2._reject(t3), Et(e2), null));\n }\nfunction qt(e2) {\n  return e2._closeRequest!==  undefined||  e2._inFlightCloseRequest!==  undefined;\n }\nfunction Et(e2) {\n  e2._closeRequest!==  undefined&&(  e2._closeRequest._reject(e2._storedError), e2._closeRequest=  undefined);\n  const t2=  e2._writer;\n  t2!==  undefined&&  Jt(t2, e2._storedError);\n }\nfunction Wt(e2, t2) {\n  const r2=  e2._writer;\n  r2!==  undefined&&  t2!==  e2._backpressure&&(  t2?  function(e3) {\n    Zt(e3);\n   }(r2): or(r2)), e2._backpressure=  t2;\n }\nObject.defineProperties(WritableStream.prototype, { abort: { enumerable: true},  close: { enumerable: true},  getWriter: { enumerable: true},  locked: { enumerable: true}}),   o(WritableStream.prototype.abort, \"abort\"), o(WritableStream.prototype.close, \"close\"), o(WritableStream.prototype.getWriter, \"getWriter\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStream.prototype, Symbol.toStringTag, { value: \"WritableStream\", configurable: true});\n\nclass WritableStreamDefaultWriter {\n             constructor(e2){\n    if( $(e2, 1, \"WritableStreamDefaultWriter\"), pt(e2, \"First parameter\"), vt(e2))\n      throw new TypeError(\"This stream has already been locked for exclusive writing by another writer\");\n    this._ownerWritableStream=  e2, e2._writer=  this;\n    const t2=  e2._state;\n    if( t2===  \"writable\")\n      !qt(e2)&&  e2._backpressure?  Zt(this):  tr(this), Gt(this);else\n         if( t2===  \"erroring\")\n      er(this, e2._storedError), Gt(this);else\n         if( t2===  \"closed\")\n      tr(this), Gt(r2=  this), Kt(r2);else\n         {\n      const t3=  e2._storedError;\n      er(this, t3), Xt(this, t3);\n     }\n    var r2;\n   }\n            get closed(){\n    return Ot(this)?  this._closedPromise:  d(Vt(\"closed\"));\n   }\n                 get desiredSize(){\n    if( !Ot(this))\n      throw Vt(\"desiredSize\");\n    if( this._ownerWritableStream===  undefined)\n      throw Ut(\"desiredSize\");\n    return function(e2) {\n      const t2=  e2._ownerWritableStream, r2=  t2._state;\n      if( r2===  \"errored\"||  r2===  \"erroring\")\n        return null;\n      if( r2===  \"closed\")\n        return 0;\n      return $t(t2._writableStreamController);\n     }(this);\n   }\n           get ready(){\n    return Ot(this)?  this._readyPromise:  d(Vt(\"ready\"));\n   }\n       abort(e2=undefined){\n    return Ot(this)?  this._ownerWritableStream===  undefined?  d(Ut(\"abort\")):  function(e3, t2) {\n      return wt(e3._ownerWritableStream, t2);\n     }(this,e2):  d(Vt(\"abort\"));\n   }\n       close(){\n    if( !Ot(this))\n      return d(Vt(\"close\"));\n    const e2=  this._ownerWritableStream;\n    return e2===  undefined?  d(Ut(\"close\")):  qt(e2)?  d(new TypeError(\"Cannot close an already-closing stream\")):  Bt(this);\n   }\n             releaseLock(){\n    if( !Ot(this))\n      throw Vt(\"releaseLock\");\n    this._ownerWritableStream!==  undefined&&  At(this);\n   }\n       write(e2=undefined){\n    return Ot(this)?  this._ownerWritableStream===  undefined?  d(Ut(\"write to\")):  zt(this, e2):  d(Vt(\"write\"));\n   }}\n\nfunction Ot(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_ownerWritableStream\")&&  e2 instanceof WritableStreamDefaultWriter;\n }\nfunction Bt(e2) {\n  return Rt(e2._ownerWritableStream);\n }\nfunction kt(e2, t2) {\n  e2._closedPromiseState===  \"pending\"?  Jt(e2, t2):  function(e3, t3) {\n    Xt(e3, t3);\n   }(e2,t2);\n }\nfunction jt(e2, t2) {\n  e2._readyPromiseState===  \"pending\"?  rr(e2, t2):  function(e3, t3) {\n    er(e3, t3);\n   }(e2,t2);\n }\nfunction At(e2) {\n  const t2=  e2._ownerWritableStream, r2=  new TypeError(\"Writer was released and can no longer be used to monitor the stream's closedness\");\n  jt(e2, r2), kt(e2, r2), t2._writer=  undefined, e2._ownerWritableStream=  undefined;\n }\nfunction zt(e2, t2) {\n  const r2=  e2._ownerWritableStream, o2=  r2._writableStreamController, n2=  function(e3, t3) {\n    if( e3._strategySizeAlgorithm===  undefined)\n      return 1;\n    try {\n      return e3._strategySizeAlgorithm(t3);\n     }catch( t4) {\n      return Yt(e3, t4), 1;\n     }\n   }(o2,t2);\n  if( r2!==  e2._ownerWritableStream)\n    return d(Ut(\"write to\"));\n  const a2=  r2._state;\n  if( a2===  \"errored\")\n    return d(r2._storedError);\n  if( qt(r2)||  a2===  \"closed\")\n    return d(new TypeError(\"The stream is closing or closed and cannot be written to\"));\n  if( a2===  \"erroring\")\n    return d(r2._storedError);\n  const i2=  function(e3) {\n    return u((t3, r3)=>  {\n      const o3=  { _resolve: t3, _reject: r3};\n      e3._writeRequests.push(o3);\n     });\n   }(r2);\n  return function(e3, t3, r3) {\n    try {\n      ve(e3, t3, r3);\n     }catch( t4) {\n      return void Yt(e3, t4);\n     }\n    const o3=  e3._controlledWritableStream;\n    if( !qt(o3)&&  o3._state===  \"writable\") {\n      Wt(o3, xt(e3));\n     }\n    Mt(e3);\n   }(o2,t2, n2), i2;\n }\nObject.defineProperties(WritableStreamDefaultWriter.prototype, { abort: { enumerable: true},  close: { enumerable: true},  releaseLock: { enumerable: true},  write: { enumerable: true},  closed: { enumerable: true},  desiredSize: { enumerable: true},  ready: { enumerable: true}}),   o(WritableStreamDefaultWriter.prototype.abort, \"abort\"), o(WritableStreamDefaultWriter.prototype.close, \"close\"), o(WritableStreamDefaultWriter.prototype.releaseLock, \"releaseLock\"), o(WritableStreamDefaultWriter.prototype.write, \"write\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStreamDefaultWriter.prototype, Symbol.toStringTag, { value: \"WritableStreamDefaultWriter\", configurable: true});\nvar Dt=  {};\n\nclass WritableStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get abortReason(){\n    if( !Lt(this))\n      throw Ht(\"abortReason\");\n    return this._abortReason;\n   }\n            get signal(){\n    if( !Lt(this))\n      throw Ht(\"signal\");\n    if( this._abortController===  undefined)\n      throw new TypeError(\"WritableStreamDefaultController.prototype.signal is not supported\");\n    return this._abortController.signal;\n   }\n       error(e2=undefined){\n    if( !Lt(this))\n      throw Ht(\"error\");\n    this._controlledWritableStream._state===  \"writable\"&&  Qt(this, e2);\n   }\n    [w](e2){\n    const t2=  this._abortAlgorithm(e2);\n    return It(this), t2;\n   }\n    [R](){\n    we(this);\n   }}\n\nfunction Lt(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledWritableStream\")&&  e2 instanceof WritableStreamDefaultController;\n }\nfunction Ft(e2, t2, r2, o2, n2, a2, i2, l2) {\n  t2._controlledWritableStream=  e2, e2._writableStreamController=  t2, t2._queue=  undefined, t2._queueTotalSize=  undefined, we(t2), t2._abortReason=  undefined, t2._abortController=  function() {\n    if( typeof AbortController==  \"function\")\n      return new AbortController();\n   }(),t2._started=  false, t2._strategySizeAlgorithm=  l2, t2._strategyHWM=  i2, t2._writeAlgorithm=  o2, t2._closeAlgorithm=  n2, t2._abortAlgorithm=  a2;\n  const s2=  xt(t2);\n  Wt(e2, s2);\n  b(c(r2()), ()=>(  t2._started=  true, Mt(t2), null), (r3)=>(  t2._started=  true, Tt(e2, r3), null));\n }\nfunction It(e2) {\n  e2._writeAlgorithm=  undefined, e2._closeAlgorithm=  undefined, e2._abortAlgorithm=  undefined, e2._strategySizeAlgorithm=  undefined;\n }\nfunction $t(e2) {\n  return e2._strategyHWM-  e2._queueTotalSize;\n }\nfunction Mt(e2) {\n  const t2=  e2._controlledWritableStream;\n  if( !e2._started)\n    return;\n  if( t2._inFlightWriteRequest!==  undefined)\n    return;\n  if( t2._state===  \"erroring\")\n    return void Pt(t2);\n  if( e2._queue.length===  0)\n    return;\n  const r2=  e2._queue.peek().value;\n  r2===  Dt?  function(e3) {\n    const t3=  e3._controlledWritableStream;\n    (function(e4) {\n      e4._inFlightCloseRequest=  e4._closeRequest, e4._closeRequest=  undefined;\n     })(t3),ge(e3);\n    const r3=  e3._closeAlgorithm();\n    It(e3), b(r3, ()=>(  function(e4) {\n      e4._inFlightCloseRequest._resolve(undefined), e4._inFlightCloseRequest=  undefined, e4._state===  \"erroring\"&&(  e4._storedError=  undefined, e4._pendingAbortRequest!==  undefined&&(  e4._pendingAbortRequest._resolve(), e4._pendingAbortRequest=  undefined)), e4._state=  \"closed\";\n      const t4=  e4._writer;\n      t4!==  undefined&&  Kt(t4);\n     }(t3),null), (e4)=>(  function(e5, t4) {\n      e5._inFlightCloseRequest._reject(t4), e5._inFlightCloseRequest=  undefined, e5._pendingAbortRequest!==  undefined&&(  e5._pendingAbortRequest._reject(t4), e5._pendingAbortRequest=  undefined), Tt(e5, t4);\n     }(t3,e4), null));\n   }(e2): function(e3, t3) {\n    const r3=  e3._controlledWritableStream;\n    (function(e4) {\n      e4._inFlightWriteRequest=  e4._writeRequests.shift();\n     })(r3);\n    const o2=  e3._writeAlgorithm(t3);\n    b(o2, ()=>  {\n      (function(e4) {\n        e4._inFlightWriteRequest._resolve(undefined), e4._inFlightWriteRequest=  undefined;\n       })(r3);\n      const t4=  r3._state;\n      if( ge(e3), !qt(r3)&&  t4===  \"writable\") {\n        const t5=  xt(e3);\n        Wt(r3, t5);\n       }\n      return Mt(e3), null;\n     },(t4)=>(  r3._state===  \"writable\"&&  It(e3), function(e4, t5) {\n      e4._inFlightWriteRequest._reject(t5), e4._inFlightWriteRequest=  undefined, Tt(e4, t5);\n     }(r3,t4), null));\n   }(e2,r2);\n }\nfunction Yt(e2, t2) {\n  e2._controlledWritableStream._state===  \"writable\"&&  Qt(e2, t2);\n }\nfunction xt(e2) {\n  return $t(e2)<=  0;\n }\nfunction Qt(e2, t2) {\n  const r2=  e2._controlledWritableStream;\n  It(e2), Ct(r2, t2);\n }\nfunction Nt(e2) {\n  return new TypeError( `WritableStream.prototype.${e2} can only be used on a WritableStream`);\n }\nfunction Ht(e2) {\n  return new TypeError( `WritableStreamDefaultController.prototype.${e2} can only be used on a WritableStreamDefaultController`);\n }\nfunction Vt(e2) {\n  return new TypeError( `WritableStreamDefaultWriter.prototype.${e2} can only be used on a WritableStreamDefaultWriter`);\n }\nfunction Ut(e2) {\n  return new TypeError(\"Cannot \"+  e2+  \" a stream using a released writer\");\n }\nfunction Gt(e2) {\n  e2._closedPromise=  u((t2, r2)=>  {\n    e2._closedPromise_resolve=  t2, e2._closedPromise_reject=  r2, e2._closedPromiseState=  \"pending\";\n   });\n }\nfunction Xt(e2, t2) {\n  Gt(e2), Jt(e2, t2);\n }\nfunction Jt(e2, t2) {\n  e2._closedPromise_reject!==  undefined&&(  p(e2._closedPromise), e2._closedPromise_reject(t2), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined, e2._closedPromiseState=  \"rejected\");\n }\nfunction Kt(e2) {\n  e2._closedPromise_resolve!==  undefined&&(  e2._closedPromise_resolve(undefined), e2._closedPromise_resolve=  undefined, e2._closedPromise_reject=  undefined, e2._closedPromiseState=  \"resolved\");\n }\nfunction Zt(e2) {\n  e2._readyPromise=  u((t2, r2)=>  {\n    e2._readyPromise_resolve=  t2, e2._readyPromise_reject=  r2;\n   }),e2._readyPromiseState=  \"pending\";\n }\nfunction er(e2, t2) {\n  Zt(e2), rr(e2, t2);\n }\nfunction tr(e2) {\n  Zt(e2), or(e2);\n }\nfunction rr(e2, t2) {\n  e2._readyPromise_reject!==  undefined&&(  p(e2._readyPromise), e2._readyPromise_reject(t2), e2._readyPromise_resolve=  undefined, e2._readyPromise_reject=  undefined, e2._readyPromiseState=  \"rejected\");\n }\nfunction or(e2) {\n  e2._readyPromise_resolve!==  undefined&&(  e2._readyPromise_resolve(undefined), e2._readyPromise_resolve=  undefined, e2._readyPromise_reject=  undefined, e2._readyPromiseState=  \"fulfilled\");\n }\nObject.defineProperties(WritableStreamDefaultController.prototype, { abortReason: { enumerable: true},  signal: { enumerable: true},  error: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(WritableStreamDefaultController.prototype, Symbol.toStringTag, { value: \"WritableStreamDefaultController\", configurable: true});\nvar nr=  typeof globalThis!=  \"undefined\"?  globalThis:  typeof self!=  \"undefined\"?  self:  typeof global!=  \"undefined\"?  global:  undefined;\nvar ar=  function() {\n  const e2=  nr==  null?  undefined:  nr.DOMException;\n  return function(e3) {\n    if( typeof e3!=  \"function\"&&  typeof e3!=  \"object\")\n      return false;\n    if( e3.name!==  \"DOMException\")\n      return false;\n    try {\n      return new e3(),true;\n     }catch( e4) {\n      return false;\n     }\n   }(e2)? e2:  undefined;\n }()|| function() {\n  const e2=  function(e3, t2) {\n    this.message=  e3||  \"\", this.name=  t2||  \"Error\", Error.captureStackTrace&&  Error.captureStackTrace(this, this.constructor);\n   };\n  return o(e2, \"DOMException\"), e2.prototype=  Object.create(Error.prototype), Object.defineProperty(e2.prototype, \"constructor\", { value: e2, writable: true, configurable: true}),  e2;\n }();\nfunction ir(t2, r2, o2, n2, a2, i2) {\n  const l2=  H(t2), s2=  yt(r2);\n  t2._disturbed=  true;\n  let _2=  false, y2=  c(undefined);\n  return u((S2, g2)=>  {\n    let v2;\n    if( i2!==  undefined) {\n      if( v2=  ()=>  {\n        const e2=  i2.reason!==  undefined?  i2.reason:  new ar(\"Aborted\", \"AbortError\"), o3=  [];\n        n2||  o3.push(()=>  r2._state===  \"writable\"?  wt(r2, e2):  c(undefined)), a2||  o3.push(()=>  t2._state===  \"readable\"?  Or(t2, e2):  c(undefined)), q2(()=>  Promise.all(o3.map((e3)=>  e3())), true, e2);\n       },i2.aborted)\n        return void v2();\n      i2.addEventListener(\"abort\", v2);\n     }\n    var w2, R2, T2;\n    if( P2(t2, l2._closedPromise, (e2)=>(  n2?  E2(true, e2):  q2(()=>  wt(r2, e2), true, e2), null)), P2(r2, s2._closedPromise, (e2)=>(  a2?  E2(true, e2):  q2(()=>  Or(t2, e2), true, e2), null)), w2=  t2, R2=  l2._closedPromise, T2=  ()=>(  o2?  E2():  q2(()=>  function(e2) {\n      const t3=  e2._ownerWritableStream, r3=  t3._state;\n      return qt(t3)||  r3===  \"closed\"?  c(undefined):  r3===  \"errored\"?  d(t3._storedError):  Bt(e2);\n     }(s2)),null), w2._state===  \"closed\"?  T2():  h(R2, T2), qt(r2)||  r2._state===  \"closed\") {\n      const e2=  new TypeError(\"the destination writable stream closed before all data could be piped to it\");\n      a2?  E2(true, e2):  q2(()=>  Or(t2, e2), true, e2);\n     }\n    function C2() {\n      const e2=  y2;\n      return f(y2, ()=>  e2!==  y2?  C2():  undefined);\n     }\n    function P2(e2, t3, r3) {\n      e2._state===  \"errored\"?  r3(e2._storedError):  m(t3, r3);\n     }\n    function q2(e2, t3, o3) {\n      function n3() {\n        return b(e2(), ()=>  O2(t3, o3), (e3)=>  O2(true, e3)), null;\n       }\n      _2||(  _2=  true, r2._state!==  \"writable\"||  qt(r2)?  n3():  h(C2(), n3));\n     }\n    function E2(e2, t3) {\n      _2||(  _2=  true, r2._state!==  \"writable\"||  qt(r2)?  O2(e2, t3):  h(C2(), ()=>  O2(e2, t3)));\n     }\n    function O2(e2, t3) {\n      return At(s2), W(l2), i2!==  undefined&&  i2.removeEventListener(\"abort\", v2), e2?  g2(t3):  S2(undefined), null;\n     }\n    p(u((t3, r3)=>  {\n      (function o(n3) {\n        n3?  t3():  f(_2?  c(true):  f(s2._readyPromise, ()=>  u((t4, r4)=>  {\n          K(l2, { _chunkSteps: (r5)=>  {\n            y2=  f(zt(s2, r5), undefined, e), t4(false);\n           },_closeSteps: ()=>  t4(true), _errorSteps: r4});\n         })),o, r3);\n       })(false);\n     }));\n   });\n }\n\nclass ReadableStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get desiredSize(){\n    if( !lr(this))\n      throw pr(\"desiredSize\");\n    return hr(this);\n   }\n       close(){\n    if( !lr(this))\n      throw pr(\"close\");\n    if( !mr(this))\n      throw new TypeError(\"The stream is not in a state that permits close\");\n    dr(this);\n   }\n         enqueue(e2=undefined){\n    if( !lr(this))\n      throw pr(\"enqueue\");\n    if( !mr(this))\n      throw new TypeError(\"The stream is not in a state that permits enqueue\");\n    return fr(this, e2);\n   }\n       error(e2=undefined){\n    if( !lr(this))\n      throw pr(\"error\");\n    br(this, e2);\n   }\n    [T](e2){\n    we(this);\n    const t2=  this._cancelAlgorithm(e2);\n    return cr(this), t2;\n   }\n    [C](e2){\n    const t2=  this._controlledReadableStream;\n    if( this._queue.length>  0) {\n      const r2=  ge(this);\n      this._closeRequested&&  this._queue.length===  0?(  cr(this), Br(t2)):  sr(this), e2._chunkSteps(r2);\n     }else\n      V(t2, e2), sr(this);\n   }\n    [P](){}}\n\nfunction lr(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledReadableStream\")&&  e2 instanceof ReadableStreamDefaultController;\n }\nfunction sr(e2) {\n  if( !ur(e2))\n    return;\n  if( e2._pulling)\n    return void( e2._pullAgain=  true);\n  e2._pulling=  true;\n  b(e2._pullAlgorithm(), ()=>(  e2._pulling=  false, e2._pullAgain&&(  e2._pullAgain=  false, sr(e2)), null), (t2)=>(  br(e2, t2), null));\n }\nfunction ur(e2) {\n  const t2=  e2._controlledReadableStream;\n  if( !mr(e2))\n    return false;\n  if( !e2._started)\n    return false;\n  if( Wr(t2)&&  G(t2)>  0)\n    return true;\n  return hr(e2)>  0;\n }\nfunction cr(e2) {\n  e2._pullAlgorithm=  undefined, e2._cancelAlgorithm=  undefined, e2._strategySizeAlgorithm=  undefined;\n }\nfunction dr(e2) {\n  if( !mr(e2))\n    return;\n  const t2=  e2._controlledReadableStream;\n  e2._closeRequested=  true, e2._queue.length===  0&&(  cr(e2), Br(t2));\n }\nfunction fr(e2, t2) {\n  if( !mr(e2))\n    return;\n  const r2=  e2._controlledReadableStream;\n  if( Wr(r2)&&  G(r2)>  0)\n    U(r2, t2, false);else\n       {\n    let r3;\n    try {\n      r3=  e2._strategySizeAlgorithm(t2);\n     }catch( t3) {\n      throw br(e2, t3), t3;\n     }\n    try {\n      ve(e2, t2, r3);\n     }catch( t3) {\n      throw br(e2, t3), t3;\n     }\n   }\n  sr(e2);\n }\nfunction br(e2, t2) {\n  const r2=  e2._controlledReadableStream;\n  r2._state===  \"readable\"&&(  we(e2), cr(e2), kr(r2, t2));\n }\nfunction hr(e2) {\n  const t2=  e2._controlledReadableStream._state;\n  return t2===  \"errored\"?  null:  t2===  \"closed\"?  0:  e2._strategyHWM-  e2._queueTotalSize;\n }\nfunction mr(e2) {\n  const t2=  e2._controlledReadableStream._state;\n  return !e2._closeRequested&&  t2===  \"readable\";\n }\nfunction _r(e2, t2, r2, o2, n2, a2, i2) {\n  t2._controlledReadableStream=  e2, t2._queue=  undefined, t2._queueTotalSize=  undefined, we(t2), t2._started=  false, t2._closeRequested=  false, t2._pullAgain=  false, t2._pulling=  false, t2._strategySizeAlgorithm=  i2, t2._strategyHWM=  a2, t2._pullAlgorithm=  o2, t2._cancelAlgorithm=  n2, e2._readableStreamController=  t2;\n  b(c(r2()), ()=>(  t2._started=  true, sr(t2), null), (e3)=>(  br(t2, e3), null));\n }\nfunction pr(e2) {\n  return new TypeError( `ReadableStreamDefaultController.prototype.${e2} can only be used on a ReadableStreamDefaultController`);\n }\nfunction yr(e2, t2) {\n  return Te(e2._readableStreamController)?  function(e3) {\n    let t3, r2, o2, n2, a2, i2=  H(e3), l2=  false, s2=  false, d2=  false, f2=  false, b2=  false;\n    const h2=  u((e4)=>  {\n      a2=  e4;\n     });\n    function _2(e4) {\n      m(e4._closedPromise, (t4)=>(  e4!==  i2||(  Ne(o2._readableStreamController, t4), Ne(n2._readableStreamController, t4), f2&&  b2||  a2(undefined)), null));\n     }\n    function p2() {\n      at(i2)&&(  W(i2), i2=  H(e3), _2(i2));\n      K(i2, { _chunkSteps: (t4)=>  {\n        y(()=>  {\n          s2=  false, d2=  false;\n          const r3=  t4;\n          let i3=  t4;\n          if( !f2&&  !b2)\n            try {\n              i3=  Se(t4);\n             }catch( t5) {\n              return Ne(o2._readableStreamController, t5), Ne(n2._readableStreamController, t5), void a2(Or(e3, t5));\n             }\n          f2||  Qe(o2._readableStreamController, r3), b2||  Qe(n2._readableStreamController, i3), l2=  false, s2?  g2():  d2&&  v2();\n         });\n       },_closeSteps: ()=>  {\n        l2=  false, f2||  xe(o2._readableStreamController), b2||  xe(n2._readableStreamController), o2._readableStreamController._pendingPullIntos.length>  0&&  Ge(o2._readableStreamController, 0), n2._readableStreamController._pendingPullIntos.length>  0&&  Ge(n2._readableStreamController, 0), f2&&  b2||  a2(undefined);\n       },_errorSteps: ()=>  {\n        l2=  false;\n       }});\n     }\n    function S2(t4, r3) {\n      J(i2)&&(  W(i2), i2=  tt(e3), _2(i2));\n      const u2=  r3?  n2:  o2, c2=  r3?  o2:  n2;\n      it(i2, t4, 1, { _chunkSteps: (t5)=>  {\n        y(()=>  {\n          s2=  false, d2=  false;\n          const o3=  r3?  b2:  f2;\n          if( r3?  f2:  b2)\n            o3||  Xe(u2._readableStreamController, t5);else\n               {\n            let r4;\n            try {\n              r4=  Se(t5);\n             }catch( t6) {\n              return Ne(u2._readableStreamController, t6), Ne(c2._readableStreamController, t6), void a2(Or(e3, t6));\n             }\n            o3||  Xe(u2._readableStreamController, t5), Qe(c2._readableStreamController, r4);\n           }\n          l2=  false, s2?  g2():  d2&&  v2();\n         });\n       },_closeSteps: (e4)=>  {\n        l2=  false;\n        const t5=  r3?  b2:  f2, o3=  r3?  f2:  b2;\n        t5||  xe(u2._readableStreamController), o3||  xe(c2._readableStreamController), e4!==  undefined&&(  t5||  Xe(u2._readableStreamController, e4), !o3&&  c2._readableStreamController._pendingPullIntos.length>  0&&  Ge(c2._readableStreamController, 0)), t5&&  o3||  a2(undefined);\n       },_errorSteps: ()=>  {\n        l2=  false;\n       }});\n     }\n    function g2() {\n      if( l2)\n        return s2=  true, c(undefined);\n      l2=  true;\n      const e4=  Ve(o2._readableStreamController);\n      return e4===  null?  p2():  S2(e4._view, false), c(undefined);\n     }\n    function v2() {\n      if( l2)\n        return d2=  true, c(undefined);\n      l2=  true;\n      const e4=  Ve(n2._readableStreamController);\n      return e4===  null?  p2():  S2(e4._view, true), c(undefined);\n     }\n    function w2(o3) {\n      if( f2=  true, t3=  o3, b2) {\n        const o4=  ne([t3, r2]), n3=  Or(e3, o4);\n        a2(n3);\n       }\n      return h2;\n     }\n    function R2(o3) {\n      if( b2=  true, r2=  o3, f2) {\n        const o4=  ne([t3, r2]), n3=  Or(e3, o4);\n        a2(n3);\n       }\n      return h2;\n     }\n    function T2() { }\n    return o2=  Pr(T2, g2, w2), n2=  Pr(T2, v2, R2), _2(i2), [o2, n2];\n   }(e2): function(e3) {\n    const t3=  H(e3);\n    let r2, o2, n2, a2, i2, l2=  false, s2=  false, d2=  false, f2=  false;\n    const b2=  u((e4)=>  {\n      i2=  e4;\n     });\n    function h2() {\n      if( l2)\n        return s2=  true, c(undefined);\n      l2=  true;\n      return K(t3, { _chunkSteps: (e4)=>  {\n        y(()=>  {\n          s2=  false;\n          const t4=  e4, r3=  e4;\n          d2||  fr(n2._readableStreamController, t4), f2||  fr(a2._readableStreamController, r3), l2=  false, s2&&  h2();\n         });\n       },_closeSteps: ()=>  {\n        l2=  false, d2||  dr(n2._readableStreamController), f2||  dr(a2._readableStreamController), d2&&  f2||  i2(undefined);\n       },_errorSteps: ()=>  {\n        l2=  false;\n       }}), c(undefined);\n     }\n    function _2(t4) {\n      if( d2=  true, r2=  t4, f2) {\n        const t5=  ne([r2, o2]), n3=  Or(e3, t5);\n        i2(n3);\n       }\n      return b2;\n     }\n    function p2(t4) {\n      if( f2=  true, o2=  t4, d2) {\n        const t5=  ne([r2, o2]), n3=  Or(e3, t5);\n        i2(n3);\n       }\n      return b2;\n     }\n    function S2() { }\n    return n2=  Cr(S2, h2, _2), a2=  Cr(S2, h2, p2), m(t3._closedPromise, (e4)=>(  br(n2._readableStreamController, e4), br(a2._readableStreamController, e4), d2&&  f2||  i2(undefined), null)), [n2, a2];\n   }(e2);\n }\nfunction Sr(r2) {\n  return t(o2=  r2)&&  o2.getReader!==  undefined?  function(r3) {\n    let o3;\n    function n2() {\n      let e2;\n      try {\n        e2=  r3.read();\n       }catch( e3) {\n        return d(e3);\n       }\n      return _(e2, (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the reader.read() method must fulfill with an object\");\n        if( e3.done)\n          dr(o3._readableStreamController);else\n             {\n          const t2=  e3.value;\n          fr(o3._readableStreamController, t2);\n         }\n       });\n     }\n    function a2(e2) {\n      try {\n        return c(r3.cancel(e2));\n       }catch( e3) {\n        return d(e3);\n       }\n     }\n    return o3=  Cr(e, n2, a2, 0), o3;\n   }(r2.getReader()): function(r3) {\n    let o3;\n    const n2=  fe(r3, \"async\");\n    function a2() {\n      let e2;\n      try {\n        e2=  be(n2);\n       }catch( e3) {\n        return d(e3);\n       }\n      return _(c(e2), (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the iterator.next() method must fulfill with an object\");\n        if( e3.done)\n          dr(o3._readableStreamController);else\n             {\n          const t2=  e3.value;\n          fr(o3._readableStreamController, t2);\n         }\n       });\n     }\n    function i2(e2) {\n      const r4=  n2.iterator;\n      let o4;\n      try {\n        o4=  ue(r4, \"return\");\n       }catch( e3) {\n        return d(e3);\n       }\n      if( o4===  undefined)\n        return c(undefined);\n      return _(g(o4, r4, [e2]), (e3)=>  {\n        if( !t(e3))\n          throw new TypeError(\"The promise returned by the iterator.return() method must fulfill with an object\");\n       });\n     }\n    return o3=  Cr(e, a2, i2, 0), o3;\n   }(r2);\n  var o2;\n }\nfunction gr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  g(e2, t2, [r3]);\n }\nfunction vr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  g(e2, t2, [r3]);\n }\nfunction wr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  S(e2, t2, [r3]);\n }\nfunction Rr(e2, t2) {\n  if( (e2=   `${e2}`)!== \"bytes\")\n    throw new TypeError( `${t2} '${e2}' is not a valid enumeration value for ReadableStreamType`);\n  return e2;\n }\nfunction Tr(e2, t2) {\n  L(e2, t2);\n  const r2=  e2==  null?  undefined:  e2.preventAbort, o2=  e2==  null?  undefined:  e2.preventCancel, n2=  e2==  null?  undefined:  e2.preventClose, a2=  e2==  null?  undefined:  e2.signal;\n  return a2!==  undefined&&  function(e3, t3) {\n    if( !function(e4) {\n      if( typeof e4!=  \"object\"||  e4===  null)\n        return false;\n      try {\n        return typeof e4.aborted==  \"boolean\";\n       }catch( e5) {\n        return false;\n       }\n     }(e3))\n      throw new TypeError( `${t3} is not an AbortSignal.`);\n   }(a2, `${t2} has member 'signal' that`),{ preventAbort: Boolean(r2), preventCancel: Boolean(o2), preventClose: Boolean(n2), signal: a2};\n }\nObject.defineProperties(ReadableStreamDefaultController.prototype, { close: { enumerable: true},  enqueue: { enumerable: true},  error: { enumerable: true},  desiredSize: { enumerable: true}}),   o(ReadableStreamDefaultController.prototype.close, \"close\"), o(ReadableStreamDefaultController.prototype.enqueue, \"enqueue\"), o(ReadableStreamDefaultController.prototype.error, \"error\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStreamDefaultController.prototype, Symbol.toStringTag, { value: \"ReadableStreamDefaultController\", configurable: true});\n\nclass ReadableStream {\n             constructor(e2={},t2={}){\n    e2===  undefined?  e2=  null:  I(e2, \"First parameter\");\n    const r2=  dt(t2, \"Second parameter\"), o2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3, o3=  r3==  null?  undefined:  r3.autoAllocateChunkSize, n2=  r3==  null?  undefined:  r3.cancel, a2=  r3==  null?  undefined:  r3.pull, i2=  r3==  null?  undefined:  r3.start, l2=  r3==  null?  undefined:  r3.type;\n      return { autoAllocateChunkSize: o3===  undefined?  undefined:  Q(o3,  `${t3} has member 'autoAllocateChunkSize' that`),cancel: n2===  undefined?  undefined:  gr(n2, r3,  `${t3} has member 'cancel' that`),pull: a2===  undefined?  undefined:  vr(a2, r3,  `${t3} has member 'pull' that`),start: i2===  undefined?  undefined:  wr(i2, r3,  `${t3} has member 'start' that`),type: l2===  undefined?  undefined:  Rr(l2,  `${t3} has member 'type' that`)};\n     }(e2,\"First parameter\");\n    if( qr(this), o2.type===  \"bytes\") {\n      if( r2.size!==  undefined)\n        throw new RangeError(\"The strategy for a byte stream cannot have a size function\");\n      (function(e3, t3, r3) {\n        const o3=  Object.create(ReadableByteStreamController.prototype);\n        let n2, a2, i2;\n        n2=  t3.start!==  undefined?  ()=>  t3.start(o3):  ()=>  { },a2=  t3.pull!==  undefined?  ()=>  t3.pull(o3):  ()=>  c(undefined), i2=  t3.cancel!==  undefined?  (e4)=>  t3.cancel(e4):  ()=>  c(undefined);\n        const l2=  t3.autoAllocateChunkSize;\n        if( l2===  0)\n          throw new TypeError(\"autoAllocateChunkSize must be greater than 0\");\n        Je(e3, o3, n2, a2, i2, r3, l2);\n       })(this,o2, ut(r2, 0));\n     }else {\n      const e3=  ct(r2);\n      (function(e4, t3, r3, o3) {\n        const n2=  Object.create(ReadableStreamDefaultController.prototype);\n        let a2, i2, l2;\n        a2=  t3.start!==  undefined?  ()=>  t3.start(n2):  ()=>  { },i2=  t3.pull!==  undefined?  ()=>  t3.pull(n2):  ()=>  c(undefined), l2=  t3.cancel!==  undefined?  (e5)=>  t3.cancel(e5):  ()=>  c(undefined), _r(e4, n2, a2, i2, l2, r3, o3);\n       })(this,o2, ut(r2, 1), e3);\n     }\n   }\n            get locked(){\n    if( !Er(this))\n      throw jr(\"locked\");\n    return Wr(this);\n   }\n        cancel(e2=undefined){\n    return Er(this)?  Wr(this)?  d(new TypeError(\"Cannot cancel a stream that already has a reader\")):  Or(this, e2):  d(jr(\"cancel\"));\n   }\n           getReader(e2=undefined){\n    if( !Er(this))\n      throw jr(\"getReader\");\n    return function(e3, t2) {\n      L(e3, t2);\n      const r2=  e3==  null?  undefined:  e3.mode;\n      return { mode: r2===  undefined?  undefined:  et(r2,  `${t2} has member 'mode' that`)};\n     }(e2,\"First parameter\").mode===  undefined?  H(this):  tt(this);\n   }\n             pipeThrough(e2,t2={}){\n    if( !Er(this))\n      throw jr(\"pipeThrough\");\n    $(e2, 1, \"pipeThrough\");\n    const r2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.readable;\n      M(r3, \"readable\", \"ReadableWritablePair\"), N(r3,  `${t3} has member 'readable' that`);\n      const o3=  e3==  null?  undefined:  e3.writable;\n      return M(o3, \"writable\", \"ReadableWritablePair\"), pt(o3,  `${t3} has member 'writable' that`),{ readable: r3, writable: o3};\n     }(e2,\"First parameter\"), o2=  Tr(t2, \"Second parameter\");\n    if( Wr(this))\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream\");\n    if( vt(r2.writable))\n      throw new TypeError(\"ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream\");\n    return p(ir(this, r2.writable, o2.preventClose, o2.preventAbort, o2.preventCancel, o2.signal)), r2.readable;\n   }\n        pipeTo(e2,t2={}){\n    if( !Er(this))\n      return d(jr(\"pipeTo\"));\n    if( e2===  undefined)\n      return d(\"Parameter 1 is required in 'pipeTo'.\");\n    if( !gt(e2))\n      return d(new TypeError(\"ReadableStream.prototype.pipeTo's first argument must be a WritableStream\"));\n    let r2;\n    try {\n      r2=  Tr(t2, \"Second parameter\");\n     }catch( e3) {\n      return d(e3);\n     }\n    return Wr(this)?  d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream\")):  vt(e2)?  d(new TypeError(\"ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream\")):  ir(this, e2, r2.preventClose, r2.preventAbort, r2.preventCancel, r2.signal);\n   }\n     tee(){\n    if( !Er(this))\n      throw jr(\"tee\");\n    return ne(yr(this));\n   }\n        values(e2=undefined){\n    if( !Er(this))\n      throw jr(\"values\");\n    return function(e3, t2) {\n      const r2=  H(e3), o2=  new he(r2, t2), n2=  Object.create(me);\n      return n2._asyncIteratorImpl=  o2, n2;\n     }(this,function(e3, t2) {\n      L(e3, t2);\n      const r2=  e3==  null?  undefined:  e3.preventCancel;\n      return { preventCancel: Boolean(r2)};\n     }(e2,\"First parameter\").preventCancel);\n   }\n     [de](e2){\n    return this.values(e2);\n   }\n             static from(e2){\n    return Sr(e2);\n   }}\n\nfunction Cr(e2, t2, r2, o2=  1, n2=  ()=>  1) {\n  const a2=  Object.create(ReadableStream.prototype);\n  qr(a2);\n  return _r(a2, Object.create(ReadableStreamDefaultController.prototype), e2, t2, r2, o2, n2), a2;\n }\nfunction Pr(e2, t2, r2) {\n  const o2=  Object.create(ReadableStream.prototype);\n  qr(o2);\n  return Je(o2, Object.create(ReadableByteStreamController.prototype), e2, t2, r2, 0, undefined), o2;\n }\nfunction qr(e2) {\n  e2._state=  \"readable\", e2._reader=  undefined, e2._storedError=  undefined, e2._disturbed=  false;\n }\nfunction Er(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_readableStreamController\")&&  e2 instanceof ReadableStream;\n }\nfunction Wr(e2) {\n  return e2._reader!==  undefined;\n }\nfunction Or(t2, r2) {\n  if( t2._disturbed=  true, t2._state===  \"closed\")\n    return c(undefined);\n  if( t2._state===  \"errored\")\n    return d(t2._storedError);\n  Br(t2);\n  const o2=  t2._reader;\n  if( o2!==  undefined&&  at(o2)) {\n    const e2=  o2._readIntoRequests;\n    o2._readIntoRequests=  new v(),e2.forEach((e3)=> {\n      e3._closeSteps(undefined);\n     });\n   }\n  return _(t2._readableStreamController[T](r2), e);\n }\nfunction Br(e2) {\n  e2._state=  \"closed\";\n  const t2=  e2._reader;\n  if( t2!==  undefined&&(  A(t2), J(t2))) {\n    const e3=  t2._readRequests;\n    t2._readRequests=  new v(),e3.forEach((e4)=> {\n      e4._closeSteps();\n     });\n   }\n }\nfunction kr(e2, t2) {\n  e2._state=  \"errored\", e2._storedError=  t2;\n  const r2=  e2._reader;\n  r2!==  undefined&&(  j(r2, t2), J(r2)?  Z(r2, t2):  lt(r2, t2));\n }\nfunction jr(e2) {\n  return new TypeError( `ReadableStream.prototype.${e2} can only be used on a ReadableStream`);\n }\nfunction Ar(e2, t2) {\n  L(e2, t2);\n  const r2=  e2==  null?  undefined:  e2.highWaterMark;\n  return M(r2, \"highWaterMark\", \"QueuingStrategyInit\"), { highWaterMark: Y(r2)};\n }\nObject.defineProperties(ReadableStream, { from: { enumerable: true}}),   Object.defineProperties(ReadableStream.prototype, { cancel: { enumerable: true},  getReader: { enumerable: true},  pipeThrough: { enumerable: true},  pipeTo: { enumerable: true},  tee: { enumerable: true},  values: { enumerable: true},  locked: { enumerable: true}}),   o(ReadableStream.from, \"from\"), o(ReadableStream.prototype.cancel, \"cancel\"), o(ReadableStream.prototype.getReader, \"getReader\"), o(ReadableStream.prototype.pipeThrough, \"pipeThrough\"), o(ReadableStream.prototype.pipeTo, \"pipeTo\"), o(ReadableStream.prototype.tee, \"tee\"), o(ReadableStream.prototype.values, \"values\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ReadableStream.prototype, Symbol.toStringTag, { value: \"ReadableStream\", configurable: true}),  Object.defineProperty(ReadableStream.prototype, de, { value: ReadableStream.prototype.values, writable: true, configurable: true});\nvar zr=  (e2)=>  e2.byteLength;\no(zr, \"size\");\n\nclass ByteLengthQueuingStrategy {\n             constructor(e2){\n    $(e2, 1, \"ByteLengthQueuingStrategy\"), e2=  Ar(e2, \"First parameter\"), this._byteLengthQueuingStrategyHighWaterMark=  e2.highWaterMark;\n   }\n                   get highWaterMark(){\n    if( !Lr(this))\n      throw Dr(\"highWaterMark\");\n    return this._byteLengthQueuingStrategyHighWaterMark;\n   }\n          get size(){\n    if( !Lr(this))\n      throw Dr(\"size\");\n    return zr;\n   }}\n\nfunction Dr(e2) {\n  return new TypeError( `ByteLengthQueuingStrategy.prototype.${e2} can only be used on a ByteLengthQueuingStrategy`);\n }\nfunction Lr(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_byteLengthQueuingStrategyHighWaterMark\")&&  e2 instanceof ByteLengthQueuingStrategy;\n }\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, { highWaterMark: { enumerable: true},  size: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(ByteLengthQueuingStrategy.prototype, Symbol.toStringTag, { value: \"ByteLengthQueuingStrategy\", configurable: true});\nvar Fr=  ()=>  1;\no(Fr, \"size\");\n\nclass CountQueuingStrategy {\n             constructor(e2){\n    $(e2, 1, \"CountQueuingStrategy\"), e2=  Ar(e2, \"First parameter\"), this._countQueuingStrategyHighWaterMark=  e2.highWaterMark;\n   }\n                   get highWaterMark(){\n    if( !$r(this))\n      throw Ir(\"highWaterMark\");\n    return this._countQueuingStrategyHighWaterMark;\n   }\n          get size(){\n    if( !$r(this))\n      throw Ir(\"size\");\n    return Fr;\n   }}\n\nfunction Ir(e2) {\n  return new TypeError( `CountQueuingStrategy.prototype.${e2} can only be used on a CountQueuingStrategy`);\n }\nfunction $r(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_countQueuingStrategyHighWaterMark\")&&  e2 instanceof CountQueuingStrategy;\n }\nfunction Mr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  g(e2, t2, [r3]);\n }\nfunction Yr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  S(e2, t2, [r3]);\n }\nfunction xr(e2, t2, r2) {\n  return F(e2, r2), (r3, o2)=>  g(e2, t2, [r3, o2]);\n }\nfunction Qr(e2, t2, r2) {\n  return F(e2, r2), (r3)=>  g(e2, t2, [r3]);\n }\nObject.defineProperties(CountQueuingStrategy.prototype, { highWaterMark: { enumerable: true},  size: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(CountQueuingStrategy.prototype, Symbol.toStringTag, { value: \"CountQueuingStrategy\", configurable: true});\n\nclass TransformStream {\n             constructor(e2={},t2={},r2={}){\n    e2===  undefined&&(  e2=  null);\n    const o2=  dt(t2, \"Second parameter\"), n2=  dt(r2, \"Third parameter\"), a2=  function(e3, t3) {\n      L(e3, t3);\n      const r3=  e3==  null?  undefined:  e3.cancel, o3=  e3==  null?  undefined:  e3.flush, n3=  e3==  null?  undefined:  e3.readableType, a3=  e3==  null?  undefined:  e3.start, i3=  e3==  null?  undefined:  e3.transform, l3=  e3==  null?  undefined:  e3.writableType;\n      return { cancel: r3===  undefined?  undefined:  Qr(r3, e3,  `${t3} has member 'cancel' that`),flush: o3===  undefined?  undefined:  Mr(o3, e3,  `${t3} has member 'flush' that`),readableType: n3, start: a3===  undefined?  undefined:  Yr(a3, e3,  `${t3} has member 'start' that`),transform: i3===  undefined?  undefined:  xr(i3, e3,  `${t3} has member 'transform' that`),writableType: l3};\n     }(e2,\"First parameter\");\n    if( a2.readableType!==  undefined)\n      throw new RangeError(\"Invalid readableType specified\");\n    if( a2.writableType!==  undefined)\n      throw new RangeError(\"Invalid writableType specified\");\n    const i2=  ut(n2, 0), l2=  ct(n2), s2=  ut(o2, 1), f2=  ct(o2);\n    let h2;\n    (function(e3, t3, r3, o3, n3, a3) {\n      function i3() {\n        return t3;\n       }\n      function l3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( e4._backpressure) {\n            return _(e4._backpressureChangePromise, ()=>  {\n              const o4=  e4._writable;\n              if( o4._state===  \"erroring\")\n                throw o4._storedError;\n              return Zr(r4, t5);\n             });\n           }\n          return Zr(r4, t5);\n         }(e3,t4);\n       }\n      function s3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( r4._finishPromise!==  undefined)\n            return r4._finishPromise;\n          const o4=  e4._readable;\n          r4._finishPromise=  u((e5, t6)=>  {\n            r4._finishPromise_resolve=  e5, r4._finishPromise_reject=  t6;\n           });\n          const n4=  r4._cancelAlgorithm(t5);\n          return Jr(r4), b(n4, ()=>(  o4._state===  \"errored\"?  ro(r4, o4._storedError):(  br(o4._readableStreamController, t5), to(r4)), null), (e5)=>(  br(o4._readableStreamController, e5), ro(r4, e5), null)), r4._finishPromise;\n         }(e3,t4);\n       }\n      function c2() {\n        return function(e4) {\n          const t4=  e4._transformStreamController;\n          if( t4._finishPromise!==  undefined)\n            return t4._finishPromise;\n          const r4=  e4._readable;\n          t4._finishPromise=  u((e5, r5)=>  {\n            t4._finishPromise_resolve=  e5, t4._finishPromise_reject=  r5;\n           });\n          const o4=  t4._flushAlgorithm();\n          return Jr(t4), b(o4, ()=>(  r4._state===  \"errored\"?  ro(t4, r4._storedError):(  dr(r4._readableStreamController), to(t4)), null), (e5)=>(  br(r4._readableStreamController, e5), ro(t4, e5), null)), t4._finishPromise;\n         }(e3);\n       }\n      function d2() {\n        return function(e4) {\n          return Gr(e4, false), e4._backpressureChangePromise;\n         }(e3);\n       }\n      function f3(t4) {\n        return function(e4, t5) {\n          const r4=  e4._transformStreamController;\n          if( r4._finishPromise!==  undefined)\n            return r4._finishPromise;\n          const o4=  e4._writable;\n          r4._finishPromise=  u((e5, t6)=>  {\n            r4._finishPromise_resolve=  e5, r4._finishPromise_reject=  t6;\n           });\n          const n4=  r4._cancelAlgorithm(t5);\n          return Jr(r4), b(n4, ()=>(  o4._state===  \"errored\"?  ro(r4, o4._storedError):(  Yt(o4._writableStreamController, t5), Ur(e4), to(r4)), null), (t6)=>(  Yt(o4._writableStreamController, t6), Ur(e4), ro(r4, t6), null)), r4._finishPromise;\n         }(e3,t4);\n       }\n      e3._writable=  function(e4, t4, r4, o4, n4=  1, a4=  ()=>  1) {\n        const i4=  Object.create(WritableStream.prototype);\n        return St(i4), Ft(i4, Object.create(WritableStreamDefaultController.prototype), e4, t4, r4, o4, n4, a4), i4;\n       }(i3,l3, c2, s3, r3, o3), e3._readable=  Cr(i3, d2, f3, n3, a3), e3._backpressure=  undefined, e3._backpressureChangePromise=  undefined, e3._backpressureChangePromise_resolve=  undefined, Gr(e3, true), e3._transformStreamController=  undefined;\n     })(this,u((e3)=>  {\n      h2=  e3;\n     }),s2, f2, i2, l2), function(e3, t3) {\n      const r3=  Object.create(TransformStreamDefaultController.prototype);\n      let o3, n3, a3;\n      o3=  t3.transform!==  undefined?  (e4)=>  t3.transform(e4, r3):  (e4)=>  {\n        try {\n          return Kr(r3, e4), c(undefined);\n         }catch( e5) {\n          return d(e5);\n         }\n       };\n      n3=  t3.flush!==  undefined?  ()=>  t3.flush(r3):  ()=>  c(undefined);\n      a3=  t3.cancel!==  undefined?  (e4)=>  t3.cancel(e4):  ()=>  c(undefined);\n      (function(e4, t4, r4, o4, n4) {\n        t4._controlledTransformStream=  e4, e4._transformStreamController=  t4, t4._transformAlgorithm=  r4, t4._flushAlgorithm=  o4, t4._cancelAlgorithm=  n4, t4._finishPromise=  undefined, t4._finishPromise_resolve=  undefined, t4._finishPromise_reject=  undefined;\n       })(e3,r3, o3, n3, a3);\n     }(this,a2), a2.start!==  undefined?  h2(a2.start(this._transformStreamController)):  h2(undefined);\n   }\n              get readable(){\n    if( !Nr(this))\n      throw oo(\"readable\");\n    return this._readable;\n   }\n              get writable(){\n    if( !Nr(this))\n      throw oo(\"writable\");\n    return this._writable;\n   }}\n\nfunction Nr(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_transformStreamController\")&&  e2 instanceof TransformStream;\n }\nfunction Hr(e2, t2) {\n  br(e2._readable._readableStreamController, t2), Vr(e2, t2);\n }\nfunction Vr(e2, t2) {\n  Jr(e2._transformStreamController), Yt(e2._writable._writableStreamController, t2), Ur(e2);\n }\nfunction Ur(e2) {\n  e2._backpressure&&  Gr(e2, false);\n }\nfunction Gr(e2, t2) {\n  e2._backpressureChangePromise!==  undefined&&  e2._backpressureChangePromise_resolve(), e2._backpressureChangePromise=  u((t3)=>  {\n    e2._backpressureChangePromise_resolve=  t3;\n   }),e2._backpressure=  t2;\n }\nObject.defineProperties(TransformStream.prototype, { readable: { enumerable: true},  writable: { enumerable: true}}),   typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(TransformStream.prototype, Symbol.toStringTag, { value: \"TransformStream\", configurable: true});\n\nclass TransformStreamDefaultController {\n             constructor(){\n    throw new TypeError(\"Illegal constructor\");\n   }\n                 get desiredSize(){\n    if( !Xr(this))\n      throw eo(\"desiredSize\");\n    return hr(this._controlledTransformStream._readable._readableStreamController);\n   }\n         enqueue(e2=undefined){\n    if( !Xr(this))\n      throw eo(\"enqueue\");\n    Kr(this, e2);\n   }\n       error(e2=undefined){\n    if( !Xr(this))\n      throw eo(\"error\");\n    var t2;\n    t2=  e2, Hr(this._controlledTransformStream, t2);\n   }\n           terminate(){\n    if( !Xr(this))\n      throw eo(\"terminate\");\n    (function(e2) {\n      const t2=  e2._controlledTransformStream;\n      dr(t2._readable._readableStreamController);\n      const r2=  new TypeError(\"TransformStream terminated\");\n      Vr(t2, r2);\n     })(this);\n   }}\n\nfunction Xr(e2) {\n  return !!t(e2)&&   !!Object.prototype.hasOwnProperty.call(e2, \"_controlledTransformStream\")&&  e2 instanceof TransformStreamDefaultController;\n }\nfunction Jr(e2) {\n  e2._transformAlgorithm=  undefined, e2._flushAlgorithm=  undefined, e2._cancelAlgorithm=  undefined;\n }\nfunction Kr(e2, t2) {\n  const r2=  e2._controlledTransformStream, o2=  r2._readable._readableStreamController;\n  if( !mr(o2))\n    throw new TypeError(\"Readable side is not in a state that permits enqueue\");\n  try {\n    fr(o2, t2);\n   }catch( e3) {\n    throw Vr(r2, e3), r2._readable._storedError;\n   }\n  const n2=  function(e3) {\n    return !ur(e3);\n   }(o2);\n  n2!==  r2._backpressure&&  Gr(r2, true);\n }\nfunction Zr(e2, t2) {\n  return _(e2._transformAlgorithm(t2), undefined, (t3)=>  {\n    throw Hr(e2._controlledTransformStream, t3), t3;\n   });\n }\nfunction eo(e2) {\n  return new TypeError( `TransformStreamDefaultController.prototype.${e2} can only be used on a TransformStreamDefaultController`);\n }\nfunction to(e2) {\n  e2._finishPromise_resolve!==  undefined&&(  e2._finishPromise_resolve(), e2._finishPromise_resolve=  undefined, e2._finishPromise_reject=  undefined);\n }\nfunction ro(e2, t2) {\n  e2._finishPromise_reject!==  undefined&&(  p(e2._finishPromise), e2._finishPromise_reject(t2), e2._finishPromise_resolve=  undefined, e2._finishPromise_reject=  undefined);\n }\nfunction oo(e2) {\n  return new TypeError( `TransformStream.prototype.${e2} can only be used on a TransformStream`);\n }\nObject.defineProperties(TransformStreamDefaultController.prototype, { enqueue: { enumerable: true},  error: { enumerable: true},  terminate: { enumerable: true},  desiredSize: { enumerable: true}}),   o(TransformStreamDefaultController.prototype.enqueue, \"enqueue\"), o(TransformStreamDefaultController.prototype.error, \"error\"), o(TransformStreamDefaultController.prototype.terminate, \"terminate\"), typeof Symbol.toStringTag==  \"symbol\"&&  Object.defineProperty(TransformStreamDefaultController.prototype, Symbol.toStringTag, { value: \"TransformStreamDefaultController\", configurable: true});\n\n// ../core/src/forkStream.ts\nfunction forkStream(originalStream, count=  2) {\n  const streams=  Array.from({ length: count},  ()=>  {\n    let controller=  { current: null};\n    const stream=  new ReadableStream({\n      start(c2) {\n        controller.current=  c2;\n       },\n      cancel() {\n        console.log(\"Stream was cancelled.\");\n       }});\n\n    return {\n      stream,\n      controller};\n\n   });\n  const processStream=  async()=>   {\n    try {\n      for await( const chunk of originalStream) {\n        streams.forEach(({ stream, controller})=>   {\n          if( controller.current) {\n            controller.current.enqueue(chunk);\n           }\n         });\n       }\n      streams.forEach(({ stream, controller})=>   {\n        if( controller.current) {\n          controller.current.close();\n         }\n       });\n     }catch( err) {\n      console.error(\"Error processing stream:\", err);\n      streams.forEach(({ stream, controller})=>   {\n        if( controller.current) {\n          controller.current.error(err);\n         }\n       });\n     }\n   };\n  processStream();\n  return streams.map(({ stream})=>   stream);\n }\n// ../core/src/indentNicely/utils/flat.ts\nfunction flat(array) {\n  return [].concat(...array);\n }\n\n// ../core/src/indentNicely/createTag.ts\nvar tagTransformersSymbol=  \"COMMON_TAGS_TAG_TRANSFORMERS_SYMBOL\";\nfunction isTag(fn) {\n  return typeof fn===  \"function\"&&  fn[tagTransformersSymbol];\n }\nfunction cleanTransformers(transformers) {\n  return flat(transformers).reduce((transformers2, transformer)=>  isTag(transformer)?  [...transformers2, ...transformer[tagTransformersSymbol]]:  [...transformers2, transformer], []);\n }\nfunction getInterimTag(originalTag, extraTag) {\n  const interimTag=  function tag(strings, ...expressions) {\n    return originalTag([\"\", \"\"], extraTag(strings, ...expressions));\n   };\n  interimTag[tagTransformersSymbol]=  [...originalTag[tagTransformersSymbol], ...extraTag[tagTransformersSymbol]];\n  return interimTag;\n }\nfunction getTagCallInfo(transformers) {\n  return {\n    transformers,\n    context: transformers.map((transformer)=>  transformer.getInitialContext?  transformer.getInitialContext():  {})};\n\n }\nfunction applyHook0({ transformers, context},  hookName, initialString) {\n  return transformers.reduce((result, transformer, index)=>  transformer[hookName]?  transformer[hookName](result, context[index]):  result, initialString);\n }\nfunction applyHook1({ transformers, context},  hookName, initialString, arg1) {\n  return transformers.reduce((result, transformer, index)=>  transformer[hookName]?  transformer[hookName](result, arg1, context[index]):  result, initialString);\n }\nfunction createTag(...rawTransformers) {\n  const transformers=  cleanTransformers(rawTransformers);\n  function tag(strings, ...expressions) {\n    if( typeof strings===  \"function\") {\n      return getInterimTag(tag, strings);\n     }\n    if( !Array.isArray(strings)) {\n      return tag([strings]);\n     }\n    const tagCallInfo=  getTagCallInfo(transformers);\n    const processedTemplate=  strings.map((string)=>  applyHook0(tagCallInfo, \"onString\", string)).reduce((result, string, index)=>  \"\".concat(result, applyHook1(tagCallInfo, \"onSubstitution\", expressions[index-  1], result), string));\n    return applyHook0(tagCallInfo, \"onEndResult\", processedTemplate);\n   }\n  tag[tagTransformersSymbol]=  transformers;\n  return tag;\n }\n\n// ../core/src/indentNicely/stripIndentTransformer.ts\nvar supportedTypes=  [\"initial\", \"all\"];\nvar stripIndentTransformer=  (type=  \"initial\")=>  {\n  if( !supportedTypes.includes(type)) {\n    throw new Error( `Type not supported: ${type}`);\n   }\n  return {\n    onEndResult(endResult) {\n      if( type===  \"all\") {\n        return endResult.replace(/^[^\\S\\n]+/gm, \"\");\n       }\n      const match=  endResult.match(/^[^\\S\\n]*(?=\\S)/gm);\n      const indent=  match&&  Math.min(...match.map((el)=>  el.length));\n      if( indent) {\n        const regexp=  new RegExp( `^.{${indent}}`,\"gm\");\n        return endResult.replace(regexp, \"\");\n       }\n      return endResult;\n     }};\n\n };\nvar stripIndentTransformer_default=  stripIndentTransformer;\n\n// ../core/src/indentNicely/trimResultTransformer.ts\nvar supportedSides=  [\"\", \"start\", \"left\", \"end\", \"right\", \"smart\"];\nvar trimResultTransformer=  (side=  \"\")=>  {\n  if( !supportedSides.includes(side)) {\n    throw new Error( `Side not supported: ${side}`);\n   }\n  return {\n    onEndResult(endResult) {\n      switch( side){\n        case \"\":\n          return endResult.trim();\n        case \"start\":\n        case \"left\":\n          return endResult.replace(/^\\s*/, \"\");\n        case \"end\":\n        case \"right\":\n          return endResult.replace(/\\s*$/, \"\");\n        case \"smart\":\n          return endResult.replace(/[^\\S\\n]+$/gm, \"\").replace(/^\\n/, \"\");}\n\n     }};\n\n };\nvar trimResultTransformer_default=  trimResultTransformer;\n\n// ../core/src/indentNicely/stripIndent.ts\nvar stripIndent=  createTag(stripIndentTransformer_default(), trimResultTransformer_default(\"smart\"));\nvar stripIndent_default=  stripIndent;\n\n// ../core/src/indentNicely/utils/toString.ts\nfunction toString(value) {\n  return \"\".concat(value);\n }\n\n// ../core/src/indentNicely/utils/prefixLines.ts\nfunction prefixLines(prefix, value, skipFirst=  false) {\n  return toString(value).split( `\n`).map((line, index)=>  skipFirst&&  index===  0?  line:  \"\".concat(prefix, line)).join( `\n`);\n }\n\n// ../core/src/indentNicely/utils/stripLastNewLine.ts\nfunction stripLastNewLine(value) {\n  const stringValue=  toString(value);\n  const { length}=   stringValue;\n  return length>  0&&  stringValue[length-  1]===   `\n`?  stringValue.slice(0, length-  1):  stringValue;\n }\n\n// ../core/src/indentNicely/inlineArrayTransformer.ts\nvar inlineArrayTransformer=  ({\n  conjunction=  \"\",\n  separator=  \"\",\n  serial=  false}=\n    {})=>(  {\n  onSubstitution(substitution, resultSoFar) {\n    if( !Array.isArray(substitution)) {\n      return substitution;\n     }\n    const { length}=   substitution;\n    const lastSeparatorIndex=  conjunction&&  !serial?  length-  2:  length-  1;\n    const indentation=  resultSoFar.match(/(?:\\n)([^\\S\\n]+)$/);\n    if( conjunction&&  length>  1) {\n      substitution[length-  1]=  \"\".concat(conjunction, \" \", substitution[length-  1]);\n     }\n    return substitution.reduce((result, part, index)=>  {\n      const isFirstPart=  index===  0;\n      const strippedPart=  stripLastNewLine(part);\n      return \"\".concat(result, isFirstPart?  \"\":  indentation?   `\n`:  \" \", indentation?  prefixLines(indentation[1], strippedPart, isFirstPart):  strippedPart, index<  lastSeparatorIndex?  separator:  \"\");\n     },\"\");\n   }});\n\nvar inlineArrayTransformer_default=  inlineArrayTransformer;\n\n// ../core/src/indentNicely/splitStringTransformer.ts\nvar splitStringTransformer=  (splitBy)=>  {\n  if( typeof splitBy!==  \"string\") {\n    throw new Error(\"You need to specify a string character to split by.\");\n   }\n  return {\n    onSubstitution(substitution) {\n      if( typeof substitution===  \"string\"&&  substitution.includes(splitBy)) {\n        return substitution.split(splitBy);\n       }\n      return substitution;\n     }};\n\n };\nvar splitStringTransformer_default=  splitStringTransformer;\n\n// ../core/src/indentNicely/removeNonPrintingValuesTransformer.ts\nvar isValidValue=  (x2)=>  x2!=  null&&  !Number.isNaN(x2)&&  typeof x2!==  \"boolean\";\nvar removeNonPrintingValuesTransformer=  ()=>(  {\n  onSubstitution(substitution) {\n    if( Array.isArray(substitution)) {\n      return substitution.filter(isValidValue);\n     }\n    if( isValidValue(substitution)) {\n      return substitution;\n     }\n    return \"\";\n   }});\n\nvar removeNonPrintingValuesTransformer_default=  removeNonPrintingValuesTransformer;\n\n// ../core/src/indentNicely/index.ts\nvar indentNicely=  createTag(splitStringTransformer_default( `\n`), removeNonPrintingValuesTransformer_default(), inlineArrayTransformer_default(), stripIndent_default);\nvar indentNicely_default=  indentNicely;\n\n// ../core/src/utils.ts\nvar $c‍_indentNicely2=indentNicely_default;indentNicely2=$c‍_indentNicely2;\nvar $c‍_stripEntityAndVerb=(soulName,_verb,response)=>  {\n  let strippedResponse=  response.replace(new RegExp( `${soulName}.*?:`,\"i\"), \"\").trim();\n  strippedResponse=  strippedResponse.replace(/^[\"']|[\"']$/g, \"\").trim();\n  return strippedResponse;\n };stripEntityAndVerb=$c‍_stripEntityAndVerb;\nvar $c‍_stripEntityAndVerbFromStream=async({soulName},  stream)=>  {\n  const prefix=  new RegExp( `^${soulName}.*?:\\\\s*[\"']*`,\"i\");\n  const suffix=  /[\"']$/;\n  let isStreaming=  !prefix;\n  let prefixMatched=  !prefix;\n  let buffer=  \"\";\n  const isStreamingBuffer=  [];\n  const processedStream=  async function*()  {\n    for await( const chunk of stream) {\n      if( isStreaming) {\n        if( !suffix) {\n          yield chunk;\n          continue;\n         }\n        isStreamingBuffer.push(chunk);\n        if( isStreamingBuffer.length>  2) {\n          yield isStreamingBuffer.shift();\n         }\n        continue;\n       }\n      buffer+=  chunk;\n      if( prefix&&  prefix.test(buffer)) {\n        if( prefixMatched) {\n          isStreaming=  true;\n          buffer=  buffer.replace(prefix, \"\");\n          yield buffer;\n          buffer=  \"\";\n          continue;\n         }\n        prefixMatched=  true;\n       }\n     }\n    buffer=  [buffer, ...isStreamingBuffer].join(\"\");\n    if( !isStreaming&&  prefix) {\n      buffer=  buffer.replace(prefix, \"\");\n     }\n    if( buffer.length>  0) {\n      if( suffix) {\n        buffer=  buffer.replace(suffix, \"\");\n        yield buffer;\n        return;\n       }\n      yield buffer;\n     }\n   }();\n  return processedStream;\n };\n// ../core/src/Memory.ts\nstripEntityAndVerbFromStream=$c‍_stripEntityAndVerbFromStream;var $c‍_ChatMessageRoleEnum;$h‍_live.ChatMessageRoleEnum($c‍_ChatMessageRoleEnum);\n((ChatMessageRoleEnum2)=>  {\n  ChatMessageRoleEnum2[\"System\"]=  \"system\";\n  ChatMessageRoleEnum2[\"User\"]=  \"user\";\n  ChatMessageRoleEnum2[\"Assistant\"]=  \"assistant\";\n  ChatMessageRoleEnum2[\"Function\"]=  \"function\";\n })(ChatMessageRoleEnum||= {});\nfunction isOpenAIText(content) {\n  return \"type\"in  content&&  content.type===  \"text\";\n }\nfunction isGoogleText(content) {\n  return \"text\"in  content&&  !(\"type\"in  content);\n }\nfunction isText(content) {\n  return isOpenAIText(content)||  isGoogleText(content);\n }\nfunction isOpenAIImage(content) {\n  return \"type\"in  content&&  content.type===  \"image_url\";\n }\nfunction isAnthropicImage(content) {\n  return \"type\"in  content&&  content.type===  \"image\"&&  \"source\"in  content;\n }\nfunction isGoogleImage(content) {\n  return \"inlineData\"in  content&&  content.inlineData.mimeType.startsWith(\"image/\");\n }\nfunction isImage(content) {\n  return isOpenAIImage(content)||  isAnthropicImage(content)||  isGoogleImage(content);\n }\nfunction isGoogleAudio(content) {\n  return \"inlineData\"in  content&&  content.inlineData.mimeType.startsWith(\"audio/\");\n }\nfunction isAudio(content) {\n  return isGoogleAudio(content);\n }\nvar $c‍_ContentTypeGuards={\n  isOpenAIText,\n  isGoogleText,\n  isText,\n  isOpenAIImage,\n  isAnthropicImage,\n  isGoogleImage,\n  isImage,\n  isGoogleAudio,\n  isAudio};\n\n// soul-engine-bundle/index.ts\nContentTypeGuards=$c‍_ContentTypeGuards;var getHooks=()=>{\n  if( !globalThis.soul) {\n    throw new Error(\"missing soul, are you running this on the soul engine?\");\n   }\n  return globalThis.soul.__hooks;\n };\nvar $c‍_useActions=()=>{\n  return getHooks().useActions();\n };useActions=$c‍_useActions;\nvar $c‍_useTTS=(opts)=>{\n  return getHooks().useTTS(opts);\n };useTTS=$c‍_useTTS;\nvar $c‍_useProcessManager=()=>{\n  return getHooks().useProcessManager();\n };useProcessManager=$c‍_useProcessManager;\nvar $c‍_usePerceptions=()=>{\n  return getHooks().usePerceptions();\n };usePerceptions=$c‍_usePerceptions;\nvar $c‍_useProcessMemory=(initialValue)=>{\n  return getHooks().useProcessMemory(initialValue);\n };useProcessMemory=$c‍_useProcessMemory;\nvar $c‍_useSoulStore=()=>{\n  return getHooks().useSoulStore();\n };useSoulStore=$c‍_useSoulStore;\nvar $c‍_useBlueprintStore=(bucketName)=>{\n  return getHooks().useBlueprintStore(bucketName);\n };useBlueprintStore=$c‍_useBlueprintStore;\nvar $c‍_useOrganizationStore=(bucketName)=>{\n  return getHooks().useOrganizationStore(bucketName);\n };useOrganizationStore=$c‍_useOrganizationStore;\nvar $c‍_useSoulMemory=(name,initialValue)=> {\n  return getHooks().useSoulMemory(name, initialValue);\n };useSoulMemory=$c‍_useSoulMemory;\nvar $c‍_useRag=(bucketName)=>{\n  return getHooks().useRag(bucketName);\n };useRag=$c‍_useRag;\nvar $c‍_useTool=(toolName)=>{\n  return getHooks().useTool(toolName);\n };useTool=$c‍_useTool;\nvar $c‍_useSharedContext=(contextName)=>{\n  return getHooks().useSharedContext(contextName);\n };\n\n// soul-engine-bundle/opensouls-bundle.ts\nuseSharedContext=$c‍_useSharedContext;class FakeWorkingMemory{}\n\nvar $c‍_WorkingMemory=new Proxy(FakeWorkingMemory,{\n  construct(_target, args) {\n    return new globalThis.___WorkingMemory(args[0]);\n   }});WorkingMemory=$c‍_WorkingMemory;\n})()\n//# sourceURL=main\n","__liveExportMap__":{"z":["z2",false],"createCognitiveStep":["createCognitiveStep",true],"indentNicely":["indentNicely2",true],"stripEntityAndVerb":["stripEntityAndVerb",true],"stripEntityAndVerbFromStream":["stripEntityAndVerbFromStream",true],"ChatMessageRoleEnum":["ChatMessageRoleEnum",true],"ContentTypeGuards":["ContentTypeGuards",true],"useActions":["useActions",true],"useTTS":["useTTS",true],"useProcessManager":["useProcessManager",true],"usePerceptions":["usePerceptions",true],"useProcessMemory":["useProcessMemory",true],"useSoulStore":["useSoulStore",true],"useBlueprintStore":["useBlueprintStore",true],"useOrganizationStore":["useOrganizationStore",true],"useSoulMemory":["useSoulMemory",true],"useRag":["useRag",true],"useTool":["useTool",true],"useSharedContext":["useSharedContext",true],"WorkingMemory":["WorkingMemory",true]},"__reexportMap__":{},"__fixedExportMap__":{"forkStream":["forkStream"],"isOpenAIText":["isOpenAIText"],"isGoogleText":["isGoogleText"],"isText":["isText"],"isOpenAIImage":["isOpenAIImage"],"isAnthropicImage":["isAnthropicImage"],"isGoogleImage":["isGoogleImage"],"isImage":["isImage"],"isGoogleAudio":["isGoogleAudio"],"isAudio":["isAudio"]},"__needsImportMeta__":false}